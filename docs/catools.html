<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.5.2" />
<title>Using the catools Library</title>
<style type="text/css">
/* Debug borders */
p, li, dt, dd, div, pre, h1, h2, h3, h4, h5, h6 {
/*
  border: 1px solid red;
*/
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

tt {
  color: navy;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  font-family: sans-serif;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}

div.sectionbody {
  font-family: serif;
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}

pre {
  padding: 0;
  margin: 0;
}

span#author {
  color: #527bbd;
  font-family: sans-serif;
  font-weight: bold;
  font-size: 1.1em;
}
span#email {
}
span#revnumber, span#revdate, span#revremark {
  font-family: sans-serif;
}

div#footer {
  font-family: sans-serif;
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
div#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
div#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

div#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.tableblock, div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-family: sans-serif;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid silver;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid silver;
  background: #f4f4f4;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #dddddd;
  color: #777777;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > div.content {
  white-space: pre;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-family: sans-serif;
  font-weight: bold;
}
tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}


@media print {
  div#footer-badges { display: none; }
}

div#toc {
  margin-bottom: 2.5em;
}

div#toctitle {
  color: #527bbd;
  font-family: sans-serif;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}
/* Workarounds for IE6's broken and incomplete CSS2. */

div.sidebar-content {
  background: #ffffee;
  border: 1px solid silver;
  padding: 0.5em;
}
div.sidebar-title, div.image-title {
  color: #527bbd;
  font-family: sans-serif;
  font-weight: bold;
  margin-top: 0.0em;
  margin-bottom: 0.5em;
}

div.listingblock div.content {
  border: 1px solid silver;
  background: #f4f4f4;
  padding: 0.5em;
}

div.quoteblock-attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock-content {
  white-space: pre;
}
div.verseblock-attribution {
  padding-top: 0.75em;
  text-align: left;
}

div.exampleblock-content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

/* IE6 sets dynamically generated links as visited. */
div#toc a:visited { color: blue; }
</style>
<script type="text/javascript">
/*<![CDATA[*/
window.onload = function(){asciidoc.footnotes();}
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([2-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  var cont = document.getElementById("content");
  var noteholder = document.getElementById("footnotes");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      // Use [\s\S] in place of . so multi-line matches work.
      // Because JavaScript has no s (dotall) regex flag.
      note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      spans[i].innerHTML =
        "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
        "' title='View footnote' class='footnote'>" + n + "</a>]";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
}

}
/*]]>*/
</script>
</head>
<body>
<div id="header">
<h1>Using the catools Library</h1>
<span id="author">Michael Abbott</span><br />
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph"><p>Related documentation: <a href="cothread.html">Cothread Library</a>, back to
<a href="index.html">Index Page</a>.</p></div>
</div>
</div>
<h2 id="_overview">Overview</h2>
<div class="sectionbody">
<div class="paragraph"><p>The <tt>catools</tt> library provides the following functions for access to EPICS
&#8220;process variables&#8221; over channel access:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<a href="#caget"><tt>caget(pvs, ...)</tt></a>
</dt>
<dd>
<p>
Returns a single snapshot of the current value of each PV.
</p>
</dd>
<dt class="hdlist1">
<a href="#caput"><tt>caput(pvs, values, ...)</tt></a>
</dt>
<dd>
<p>
Writes values to one or more PVs.
</p>
</dd>
<dt class="hdlist1">
<a href="#camonitor"><tt>camonitor(pvs, callback, ...)</tt></a>
</dt>
<dd>
<p>
Receive notification each time any of the listed PVs changes.
</p>
</dd>
<dt class="hdlist1">
<a href="#connect"><tt>connect(pvs, ...)</tt></a>
</dt>
<dd>
<p>
Can be used to establish a connection to a list of PVs before calling the
other routines.  This routine is optional.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>To use these functions a certain amount of setup work is required.  The
following code illustrates a simple application which reads a value from one
PV, writes to another PV, and monitors a third until terminated with
control-C.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt># Library version specification required for dls libraries
from pkg_resources import require
require('numpy==1.1.0')
require('cothread')

import cothread
from cothread.catools import *

# Using caput: write 1234 into PV1.  Raises exception on failure
caput('PV1', 1234)

# Print out the value reported by PV2.
print caget('PV2')

# Monitor PV3, printing out each update as it is received.
def callback(value):
    print 'callback', value
camonitor('PV3', callback)

# Now run the camonitor process until interrupted by Ctrl-C.
cothread.WaitForQuit()</tt></pre>
</div></div>
<div class="paragraph"><p>The following details are general to all cothread applications.</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
The routine <tt>pkg_resources.require()</tt> must be used to specify a particular
version of the library to use.  The <tt>catools</tt> submodule also depends on
<tt>numpy</tt> and this should also be specified, thus the following lines are
required at the start of any catools application:
</p>
<div class="listingblock">
<div class="content">
<pre><tt>from pkg_resources import require
require('numpy==1.1.0')
require('cothread==1.15')</tt></pre>
</div></div>
<div class="paragraph"><p>or if the most recent version is ok then the version number can be omitted as
in the example.</p></div>
</li>
<li>
<p>
Any <tt>EPICS_CA_</tt> environment variables should be set at this point, before
importing <tt>catools</tt> (see <a href="#environment">below</a>).
</p>
</li>
<li>
<p>
Of course, the libraries must be imported.  The <tt>catools</tt> library is a
sub-module of the <tt>cothread</tt> library, and can be imported separately.
</p>
</li>
<li>
<p>
If <tt>camonitor</tt> is being used then the program should suspend in an event
loop of some sort.  The routine <tt>cothread.WaitForQuit()</tt> can be used, as
otherwise the <tt>camonitor</tt> activity has no opportunity to run before the
program exits!
</p>
</li>
</ol></div>
</div>
<h2 id="_tips_and_tricks">Tips and Tricks</h2>
<div class="sectionbody">
<div class="paragraph"><p>The following notes may be helpful when using this library.</p></div>
<h3 id="environment">Environment Variables</h3><div style="clear:left"></div>
<div class="paragraph"><p>A number of environment variables affect the operation of channel access.
These can be set using the <tt>os.environ</tt> dictionary&#8201;&#8212;&#8201;but note that these
need to be set <em>before</em> loading the <tt>catools</tt> module.  The following are
documented in the
<a href="http://www.aps.anl.gov/epics/EpicsDocumentation/AppDevManuals/ChannelAccess/cadoc_4.htm">
EPICS channel access developers manual</a>.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>EPICS_CA_MAX_ARRAY_BYTES</tt>
</dt>
<dd>
<p>
Configures the maximum number of bytes that can be
transferred in a single channel access message.
</p>
</dd>
<dt class="hdlist1">
<tt>EPICS_CA_ADDR_LIST</tt>
</dt>
<dd>
<p>
A space separated list of channel access server
addresses.
</p>
</dd>
<dt class="hdlist1">
<tt>EPICS_CA_AUTO_ADDR_LIST</tt>
</dt>
<dd>
<p>
If set to &#8220;NO&#8221; the automatic scanning of
networks is disabled.
</p>
</dd>
<dt class="hdlist1">
<tt>EPICS_CA_CONN_TMO</tt>
</dt>
<dd>
<p>
Connection timeout, 30 seconds by default.
</p>
</dd>
<dt class="hdlist1">
<tt>EPICS_CA_BEACON_PERIOD</tt>
</dt>
<dd>
<p>
Beacon polling period, 15 seconds by default.
</p>
</dd>
<dt class="hdlist1">
<tt>EPICS_CA_SERVER_PORT</tt>, <tt>EPICS_CA_REPEATER_PORT</tt>
</dt>
<dd>
<p>
Set these to configure the
ports used to connect to channel access.  By default ports 5064 and 5065 are
used (respectively); for testing we use 6064 and 6065.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Example code:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>import os
os.environ['EPICS_CA_MAX_ARRAY_BYTES'] = '1000000'

# Note: the first import of catools must come after the environ is set up.
from cothread.catools import *</tt></pre>
</div></div>
</div>
<h2 id="_function_reference">Function Reference</h2>
<div class="sectionbody">
<div class="paragraph"><p>The <tt>catools</tt> API consists of the three functions <tt>caput</tt>, <tt>caget</tt> and
<tt>camonitor</tt> together with an auxilliary <tt>connect</tt> function.  The functions
<tt>caget</tt> and <tt>camonitor</tt> return or deliver &#8220;augmented&#8221; values which are
documented in more detail in the section <a href="#Values">Working with Values</a>
below.</p></div>
<h3 id="Common">Common Notes</h3><div style="clear:left"></div>
<div class="paragraph"><p>All four functions take an argument <tt>pvs</tt> which can specify the name of a
single PV or can be a list of PVs.  In all cases the returned result has the
same &#8220;shape&#8221; as the <tt>pvs</tt> argument, in other words, if <tt>pvs</tt> is a single
string then a single value (error code, value, or subscription) is returned,
and if <tt>pvs</tt> is a list then a list of exactly the same length is returned.</p></div>
<div class="paragraph"><p>In general there are advantages to calling <tt>caput</tt>, <tt>caget</tt> or <tt>connect</tt> on a
list of PVs, as in this case the channel access delays will occur in parallel.</p></div>
<div class="paragraph"><p>Several arguments are common amongst several: <tt>throw</tt> determines how errors
are handled, <tt>timeout</tt> determines timeouts, and finally <tt>datatype</tt>, <tt>format</tt>
and <tt>count</tt> determine data formats and are documented in <a href="#Augmented">Augmented Values</a>.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>timeout</tt>
</dt>
<dd>
<p>
The <tt>timeout</tt> argument specified how long <tt>caput</tt> or <tt>caget</tt> will wait for the
entire operation to complete.  This timeout is in seconds, and can be one of
several formats: a timeout interval in seconds, an absolute deadline (in
<tt>time()</tt> format) as a single element tuple, or None to specify that no timeout
will occur.  Note that a timeout of 0 will timeout immediately if any waiting
is required.
</p>
<div class="paragraph"><p>If a timeout occurs then a <tt>Timedout</tt> exception will be raised unless
<tt>throw=False</tt> has been set.</p></div>
</dd>
<dt class="hdlist1">
<tt>throw</tt>
</dt>
<dd>
<p>
This parameter determines the behaviour of <tt>caget</tt> and <tt>caput</tt> when an error
occurs.  If <tt>throw=True</tt> (the default) is set then an exception is raised,
otherwise if <tt>False</tt> is specified an error code value is returned for each
failing PV.
</p>
</dd>
</dl></div>
<h3 id="_functions">Functions</h3><div style="clear:left"></div>
<div class="dlist" id="caput"><dl>
<dt class="hdlist1">
<tt>caput(pvs, values, repeat_value=False, datatype=None, wait=False, timeout=5, callback=None, throw=True)</tt>
</dt>
<dd>
<p>
Writes values to one or more PVs.  If <tt>pvs</tt> is a single string then <tt>values</tt>
is treated as a single value to be written to the named process variable,
otherwise <tt>pvs</tt> must be iterable, and unless <tt>repeat_value=True</tt> is set,
<tt>values</tt> must also be an iterable of the same length in which case
<tt>values[i]</tt> is written to <tt>pvs[i]</tt>.  Otherwise, if a single value is given or
if <tt>repeat_value=True</tt> is specified, <tt>values</tt> is written to all PVs.
</p>
<div class="paragraph"><p>The arguments control the behavour of caput as follows:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>repeat_value</tt>
</dt>
<dd>
<p>
When writing a value to a list of PVs ensures that <tt>values</tt> is treated as a
single value to be written to each PV.
</p>
</dd>
<dt class="hdlist1">
<tt>datatype</tt>
</dt>
<dd>
<p>
See documentation for <a href="#Augmented">Augmented Values</a> below.  Used to force
transmitted data to the requested format, or select special alarm
acknowledgement handling.  Note that only standard Python type conversion will
be done, in particular conversion to and from strings is <em>not</em> automatic!
</p>
</dd>
<dt class="hdlist1">
<tt>wait</tt>
</dt>
<dd>
<p>
If <tt>wait=True</tt> is specified then channel access put with callback is
invoked, and the <tt>caput</tt> operation will wait until the server
acknowledges successful completion before returning.
</p>
</dd>
<dt class="hdlist1">
<tt>callback</tt>
</dt>
<dd>
<p>
If a <tt>callback</tt> is specified then channel access put with callback is invoked
and the given <tt>callback</tt> function will be called with the put response as a
<tt>ca_nothing</tt> object passed as the only argument.  All <tt>caput</tt> callbacks will
will be called on a dedicated caput callback thread.
</p>
<div class="paragraph"><p>Unless <tt>wait</tt> is specified the call to <tt>caput</tt> will complete as soon as the
caput has been initiated.  If <tt>wait</tt> is specified, whether <tt>caput</tt> returns
before or after <tt>callback</tt> is called is unpredictable.</p></div>
</dd>
<dt class="hdlist1">
<tt>timeout</tt>, <tt>throw</tt>
</dt>
<dd>
<p>
Documented in <a href="#Common">Common Notes</a> above.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>The return value from <tt>caput</tt> is either a list or a single value, depending on
the shape of <tt>pvs</tt>.  For each PV a <tt>ca_nothing</tt> success code is
returned on success, otherwise either an exception is raised or an appropriate
error code is returned for each failing PV if <tt>throw=True</tt> is set.  The return
code can be tested for boolean success, so for example it
is possible to write:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>if not caput(pv, value, throw=False):
    # process caput error</tt></pre>
</div></div>
<div class="paragraph"><p>If all the PVs listed in <tt>pvs</tt> have already been connected, through a
successful call to any <tt>catools</tt> method, then the library guarantees that the
puts for each PV will occur strictly in sequence.  For any PVs which need a
connection to be established the order of execution of puts is completely
undefined.</p></div>
</dd>
<dt class="hdlist1">
<tt>caget(pvs, timeout=5, datatype=None, format=FORMAT_RAW, count=0, throw=True)</tt>
</dt>
<dd>
<p>
Retrieves a value from one or more PVs.  If <tt>pvs</tt> is a single string then
a single value is returned, otherwise a list of values is returned.  Each
value returned is an <a href="#Augmented">Augmented Value</a>, see
below for details.
</p>
<div class="paragraph" id="caget"><p>If <tt>.ok</tt> is <tt>False</tt> then the <tt>.errorcode</tt> field is set to the appropriate
<tt>ECA_</tt> error code and <tt>str(value)</tt> will return an error message.</p></div>
<div class="paragraph"><p>The various arguments control the behaviour of <tt>caget</tt> as follows:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>datatype</tt>, <tt>format</tt>, <tt>count</tt>
</dt>
<dd>
<p>
See documentation for <a href="#Augmented">Augmented Values</a> below.
</p>
</dd>
<dt class="hdlist1">
<tt>timeout</tt>, <tt>throw</tt>
</dt>
<dd>
<p>
Documented in <a href="#Common">Common Notes</a> above.  If a value cannot be retrieved
and <tt>throw=False</tt> is set then for each failing PV an empty value with
<tt>.ok==False</tt> is returned.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>The format of values returned depends on the number of values requested
for each PV.  If only one value is requested then the value is returned
as a scalar, otherwise as a numpy array.</p></div>
</dd>
<dt class="hdlist1">
<tt>camonitor(pvs, callback, events=DBE_VALUE, datatype=None, format=FORMAT_RAW, count=0, all_updates=False, notify_disconnect=False)</tt>
</dt>
<dd>
<p>
Creates a subscription to one or more PVs, returning a subscription
object for each PV.  If a single PV is given then a single subscription
object is returned, otherwise a list of subscriptions is returned.
</p>
<div class="paragraph" id="camonitor"><p>Subscriptions will remain active until the <tt>.close()</tt> method is called on
the returned subscription object.</p></div>
<div class="paragraph"><p>The precise way in which the callback routine is called on updates
depends on whether <tt>pvs</tt> is a single name or a list of names.  If it is
single name then it is called as</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>callback(value)</tt></pre>
</div></div>
<div class="paragraph"><p>for each update.  If <tt>pvs</tt> is a list of names then each update is
reported as</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>callback(value, index)</tt></pre>
</div></div>
<div class="paragraph"><p>where <tt>index</tt> is the position in the original array of PVs of the PV
generating this update.  The values passed to <tt>callback</tt> are <a href="#Augmented">Augmented Values</a>.</p></div>
<div class="paragraph"><p>The parameters modify the behaviour as follows:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>events</tt>
</dt>
<dd>
<p>
This identifies the type of update which will be notified.  A
bit-wise or of any the following are possible:
</p>
<div class="tableblock">
<table rules="none"
width="100%"
frame="void"
cellspacing="0" cellpadding="4">
<col width="15%" />
<col width="85%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><tt>DBE_VALUE</tt></p></td>
<td align="left" valign="top"><p class="table">Notify normal value changes</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>DBE_LOG</tt></p></td>
<td align="left" valign="top"><p class="table">Notify archive value changes</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>DBE_ALARM</tt></p></td>
<td align="left" valign="top"><p class="table">Notify alarm state changes</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>DBE_PROPERTY</tt></p></td>
<td align="left" valign="top"><p class="table">Notify property changes (on 3.14.11 and later servers)</p></td>
</tr>
</tbody>
</table>
</div>
</dd>
<dt class="hdlist1">
<tt>datatype</tt>, <tt>format</tt>, <tt>count</tt>
</dt>
<dd>
<p>
See documentation for <a href="#Augmented">Augmented Values</a> below.
</p>
</dd>
<dt class="hdlist1">
<tt>all_updates</tt>
</dt>
<dd>
<p>
If this is <tt>True</tt> then every update received from channel access will
be delivered to the callback, otherwise multiple updates received
between callback queue dispatches will be merged into the most recent
value.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>If updates are being merged then the value returned will be
augmented with a field <tt>.update_count</tt> recording how many updates
occurred on this value.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>notify_disconnect</tt>
</dt>
<dd>
<p>
If this is <tt>True</tt> then IOC disconnect events and channel access
error reports will be reported by calling the callback with a <tt>ca_nothing</tt>
error with <tt>.ok</tt> False.  By default <tt>False</tt> these notifications are
suppressed so that only valid values will be passed to the callback routine.
</p>
</dd>
</dl></div>
</dd>
<dt class="hdlist1">
<tt>connect(pvs, cainfo=False, wait=True, timeout=5, throw=True)</tt>
</dt>
<dd>
<p>
Establishes a connection to one or more PVs, optionally returning detailed
information about the connection.  A single PV or a list of PVs
can be given.  This does not normally need to be called, as the <tt>ca&#8230;()</tt>
routines will establish their own connections as required, but after a
successful connection we can guarantee that <tt>caput(&#8230;, wait=False)</tt> will
complete immediately without suspension and that <tt>caput(pvs, values)</tt> will
execute in order if all PVs in <tt>pvs</tt> have been successfully connected.
</p>
<div class="paragraph" id="connect"><p>It is possible to test whether a channel has successfully connected by calling
<tt>connect(pv, wait=True, timeout=0, throw=False)</tt> and testing the result.  More
detailed information about a PV can be obtained by calling <tt>connect(pv,
cainfo=True)</tt>.</p></div>
<div class="paragraph"><p>The various arguments control the behaviour of <tt>connect</tt> as follows:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>wait</tt>
</dt>
<dd>
<p>
Normally the <tt>connect</tt> routine will not return until the requested
connection is established.  If <tt>wait=False</tt> is set then a connection
request will be queued and <tt>connect</tt> will unconditionally succeed.
</p>
</dd>
<dt class="hdlist1">
<tt>cainfo</tt>
</dt>
<dd>
<div class="paragraph"><p>By default a simple <tt>ca_nothing</tt> value is returned, but if <tt>cainfo=True</tt> is
set then a <tt>ca_info</tt> structure is returned recording the following information
about the connection:</p></div>
<div class="tableblock">
<table rules="none"
width="100%"
frame="void"
cellspacing="0" cellpadding="4">
<col width="10%" />
<col width="90%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><tt>.ok</tt></p></td>
<td align="left" valign="top"><p class="table">True iff the channel was successfully connected</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>.name</tt></p></td>
<td align="left" valign="top"><p class="table">Name of PV</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>.state</tt></p></td>
<td align="left" valign="top"><p class="table">State of channel as an integer.  Look up
<tt>.state_strings[.state]</tt> for textual description.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>.host</tt></p></td>
<td align="left" valign="top"><p class="table">Host name and port of server providing this PV</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>.read</tt></p></td>
<td align="left" valign="top"><p class="table">True iff read access to this PV</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>.write</tt></p></td>
<td align="left" valign="top"><p class="table">True iff write access to this PV</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>.count</tt></p></td>
<td align="left" valign="top"><p class="table">Data count of this channel</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>.datatype</tt></p></td>
<td align="left" valign="top"><p class="table">Underlying channel datatype as <tt>DBR_</tt> value.  Look up
<tt>.datatype_strings[.datatype]</tt> for description.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>The <tt>str()</tt> representation of this structure can be printed to produce output
similar to that produced by the <tt>cainfo</tt> command line tool.</p></div>
</dd>
<dt class="hdlist1">
<tt>timeout</tt>, <tt>throw</tt>
</dt>
<dd>
<p>
Documented in <a href="#Common">Common Notes</a> above.  If a value cannot be retrieved
and <tt>throw=False</tt> is set then for each failing PV an empty value with
<tt>.ok==False</tt> is returned.
</p>
</dd>
</dl></div>
</dd>
</dl></div>
</div>
<h2 id="Values">Working with Values</h2>
<div class="sectionbody">
<div class="paragraph"><p>There are two types of values returned by catools functions: &#8220;augmented
values&#8221; and &#8220;error codes&#8221;.  The <tt>caput</tt> function only returns an error code
value (which may indicate success), while <tt>caget</tt> and <tt>camonitor</tt> will
normally return (or deliver) augmented values, but will return (or deliver) an
error code on failure.</p></div>
<div class="paragraph"><p>The following fields are common to both types of value.  This means that is is
always safe to test <tt>value.ok</tt> for a value returned by <tt>caget</tt> or <tt>caput</tt> or
delivered by <tt>camonitor</tt>.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>.ok</tt>
</dt>
<dd>
<p>
Set to <tt>True</tt> if the data is good, <tt>False</tt> if there was an error.  For
augmented values <tt>.ok</tt> is always set to <tt>True</tt>.
</p>
</dd>
<dt class="hdlist1">
<tt>.name</tt>
</dt>
<dd>
<p>
Name of the pv.
</p>
</dd>
</dl></div>
<h3 id="Augmented">Augmented Values</h3><div style="clear:left"></div>
<div class="paragraph"><p>Augmented values are normally Python or <tt>numpy</tt> values with extra fields: the
<tt>.ok</tt> and <tt>.name</tt> fields are already mentioned above, and further extra fields
will be present depending on format requested for the data.  As pointed
out above, <tt>.ok</tt> is always <tt>True</tt>.</p></div>
<div class="paragraph"><p>Four different types of augmented value are returned: strings, integers,
floating point numbers or arrays, depending on the length of the data
requested&#8201;&#8212;&#8201;an array is only used when the data length is &gt;1.</p></div>
<div class="paragraph"><p>In almost all circumstances an augmented value will behave exactly like a
normal value, but there are a few cases where differences in behaviour are
observed (these are mostly bugs).  If this occurs the augumentation can be
stripped from an augmented value <tt>value</tt> by writing <tt>+value</tt>&#8201;&#8212;&#8201;this returns
the underlying value.</p></div>
<div class="paragraph"><p>The type of augmented values is determined both by parameters passed to
<tt>caget</tt> and <tt>camonitor</tt> and by the underlying datatype.  Both of these
functions share parameters <tt>datatype</tt>, <tt>format</tt> and <tt>count</tt> which can be used
to control the type of the data returned:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>datatype</tt>
</dt>
<dd>
<div class="paragraph"><p>For <tt>caget</tt> and <tt>camonitor</tt> this controls the format of the data that will be
requested, while for <tt>caput</tt> the data will be coerced into the requested
format.  <tt>datatype</tt> can be any of the following:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
<tt>None</tt> (the default).  In this case the &#8220;native&#8221; datatype provided
    by the channel will be returned.
</p>
</li>
<li>
<p>
A <tt>DBR_</tt> value, one of the following:
</p>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>DBR_STRING</tt>
</dt>
<dd>
<p>
Strings are up to 39 characters long&#8201;&#8212;&#8201;this is a constraint
set by EPICS.  For longer strings the data type <tt>DBR_CHAR_STR</tt> can be used if
the IOC can deliver strings as arrays of char.
</p>
</dd>
<dt class="hdlist1">
<tt>DBR_CHAR</tt>, <tt>DBR_SHORT</tt>, <tt>DBR_LONG</tt>
</dt>
<dd>
<p>
These are all signed integer types,
with 8, 16 and 32 bit values respectively.  The parameter <tt>as_string</tt> can be
set to convert arrays of <tt>DBR_CHAR</tt> to strings.
</p>
</dd>
<dt class="hdlist1">
<tt>DBR_FLOAT</tt>, <tt>DBR_DOUBLE</tt>
</dt>
<dd>
<p>
Floating point values with 32 and 64 bit values,
respectively.
</p>
</dd>
<dt class="hdlist1">
<tt>DBR_ENUM</tt>
</dt>
<dd>
<p>
A 16 bit unsigned integer value representing an index into an
array of strings.  The associated strings can be retrieved by using
<tt>format=FORMAT_CTRL</tt> and inspecting the <tt>.enums</tt> field.
</p>
</dd>
</dl></div>
</li>
<li>
<p>
A python type compatible with any of the above values, such as
    <tt>int</tt>, <tt>float</tt> or <tt>str</tt>.  These correspond to <tt>DBR_LONG</tt>, <tt>DBR_DOUBLE</tt> and
    <tt>DBR_STRING</tt> respectively.
</p>
</li>
<li>
<p>
Any <tt>numpy</tt> <tt>dtype</tt> compatible with any of the above values.
</p>
</li>
<li>
<p>
The special value <tt>DBR_CHAR_STR</tt>.  This is used to request a char
    array which is then converted to a Python string on receipt.  It
    is not sensible to specify <tt>count</tt> with this option.
</p>
</li>
<li>
<p>
For <tt>caget</tt> and <tt>camonitor</tt> two further special values are supported.  In
    both of these cases <tt>format</tt> is ignored:
</p>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>DBR_STSACK_STRING</tt>
</dt>
<dd>
<p>
Returns the current value as a string together with
extra fields <tt>.status</tt>, <tt>.severity</tt>, <tt>.ackt</tt>, <tt>.acks</tt>.
</p>
</dd>
<dt class="hdlist1">
<tt>DBR_CLASS_NAME</tt>
</dt>
<dd>
<p>
Returns the name of the &#8220;enclosing interface&#8221;, typically
the record type, and typically the same as the <tt>.RTYP</tt> field.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>For <tt>caput</tt> also two further values are supported:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>DBR_PUT_ACKT</tt>, <tt>DBR_PUT_ACKS</tt>
</dt>
<dd>
<p>
These are used for global alarm
acknowledgement, where <tt>_ACKT</tt> configures whether alarms need to be
acknowleged and <tt>_ACKS</tt> acknowledges alarms of a particular severity.
</p>
</dd>
</dl></div>
</li>
</ol></div>
</dd>
<dt class="hdlist1">
<tt>format</tt>
</dt>
<dd>
<p>
This controls how much auxilliary information will be returned with
the retrieved data, and can be one of the following:
</p>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>FORMAT_RAW</tt> (default)
</dt>
<dd>
<p>
The data is returned unaugmented except for the <tt>.name</tt> and <tt>.ok</tt> fields.
</p>
</dd>
<dt class="hdlist1">
<tt>FORMAT_TIME</tt>
</dt>
<dd>
<p>
The data is augmented by timestamp fields <tt>.timestamp</tt> and <tt>.raw_stamp</tt>
together with .<tt>alarm</tt>, <tt>.status</tt> and <tt>.severity</tt> fields.  The value in
<tt>.timestamp</tt> is in <tt>time()</tt> format (seconds in Unix UTC epoch).
</p>
</dd>
<dt class="hdlist1">
<tt>FORMAT_CTRL</tt>
</dt>
<dd>
<div class="paragraph"><p>The data is augmented by channel access &#8220;control&#8221; fields.  The set of fields
returned depends on the underlying datatype as follows:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>DBR_SHORT</tt>, <tt>DBR_CHAR</tt>, <tt>DBR_LONG</tt>
</dt>
<dd>
<p>
The alarm <tt>.status</tt> and <tt>.severity</tt> fields together with <tt>.units</tt>
and limit fields:
<tt>.upper_disp_limit</tt>, <tt>.lower_disp_limit</tt>,
<tt>.upper_alarm_limit</tt>, <tt>.lower_alarm_limit</tt>,
<tt>.upper_warning_limit</tt>, <tt>.lower_warning_limit</tt>,
<tt>.upper_ctrl_limit</tt>, <tt>.lower_ctrl_limit</tt>.
The meaning of these fields is determined by channel access.
</p>
</dd>
<dt class="hdlist1">
<tt>DBR_FLOAT</tt>, <tt>DBR_DOUBLE</tt>
</dt>
<dd>
<p>
As above together with a <tt>.precision</tt> field.
</p>
</dd>
<dt class="hdlist1">
<tt>DBR_ENUM</tt>
</dt>
<dd>
<p>
Alarm <tt>.status</tt> and <tt>.severity</tt> fields together with <tt>.enums</tt>, a
list of possible enumeration strings.  The underlying value for an enumeration
will be an index into <tt>.enums</tt>.
</p>
</dd>
<dt class="hdlist1">
<tt>DBR_STRING</tt>
</dt>
<dd>
<p>
<tt>_CTRL</tt> format is not supported for this field type, and
<tt>FORMAT_TIME</tt> data is returned instead.
</p>
</dd>
</dl></div>
</dd>
</dl></div>
</dd>
<dt class="hdlist1">
<tt>count</tt>
</dt>
<dd>
<p>
If specified this can be used to limit the number of waveform points
retrieved from the server, otherwise the entire waveform is always returned.
</p>
</dd>
</dl></div>
<h4 id="_fields">Fields</h4>
<div class="paragraph"><p>Summary of all available fields in augmented values.</p></div>
<div class="paragraph"><p>The following fields are present in all augmented values.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>.name</tt>
</dt>
<dd>
<p>
Name of record, always present.
</p>
</dd>
<dt class="hdlist1">
<tt>.ok</tt>
</dt>
<dd>
<p>
Set to <tt>True</tt>, always present.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>The following fields are present in all values if <tt>FORMAT_TIME</tt> is specified.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>.raw_stamp</tt>
</dt>
<dd>
<p>
Record timestamp in raw format as provided by EPICS (but in the
local Unix epoch, not the EPICS epoch).  Is a tuple of the form <tt>(secs, nsec)</tt>
with integer seconds and nanosecond values, provided in case full ns timestamp
precision is required.
</p>
</dd>
<dt class="hdlist1">
<tt>.timestamp</tt>
</dt>
<dd>
<p>
Timestamp in seconds in format compatible with <tt>time.time()</tt>
rounded to the nearest microsecond: for nanosecond precision use <tt>.raw_stamp</tt>
instead.
</p>
<div class="paragraph"><p>To compute the timestamp in <tt>datetime</tt> format, which can be more suitable for
display applications, it can be added to the value by computing</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>import datetime
value.datetime = datetime.datetime.fromtimestamp(value.timestamp)</tt></pre>
</div></div>
</dd>
</dl></div>
<div class="paragraph"><p>The following fields are present in all values if <tt>FORMAT_TIME</tt> or
<tt>FORMAT_CTRL</tt> is specified.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>.severity</tt>
</dt>
<dd>
<p>
EPICS alarm severity, normally one of the values listed below.
</p>
<div class="tableblock">
<table rules="none"
width="100%"
frame="void"
cellspacing="0" cellpadding="4">
<col width="2%" />
<col width="98%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">0</p></td>
<td align="left" valign="top"><p class="table">&#8658; No alarm</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">1</p></td>
<td align="left" valign="top"><p class="table">&#8658; Alarm condition, minor severity</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">2</p></td>
<td align="left" valign="top"><p class="table">&#8658; Alarm condition, major severity.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">3</p></td>
<td align="left" valign="top"><p class="table">&#8658; Invalid value.</p></td>
</tr>
</tbody>
</table>
</div>
</dd>
<dt class="hdlist1">
<tt>.status</tt>
</dt>
<dd>
<p>
Reason code associated with alarm severity, always present with
<tt>.severity</tt> code.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>The following fields are present in numeric values if <tt>FORMAT_CTRL</tt> is
specified.  Values of type <tt>DBR_ENUM</tt> or <tt>DBR_STRING</tt> are not numeric.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>.units</tt>
</dt>
<dd>
<p>
Units for display.
</p>
</dd>
<dt class="hdlist1">
<tt>.upper_disp_limit</tt>, <tt>.lower_disp_limit</tt>
</dt>
<dd>
<p>
Suggested display limits for
numerical values.
</p>
</dd>
<dt class="hdlist1">
<tt>.upper_alarm_limit</tt>, <tt>.lower_alarm_limit</tt>, <tt>.upper_warning_limit</tt>, <tt>.lower_warning_limit</tt>, <tt>.upper_ctrl_limit</tt>, <tt>.lower_ctrl_limit</tt>
</dt>
<dd>
<p>
Various EPICS numeric limits.
</p>
</dd>
<dt class="hdlist1">
<tt>.precision</tt>
</dt>
<dd>
<p>
For floating point values only, the specified display precision
(or 0 if not specified).  Present if value is a floating point type.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>The following field is only present in <tt>DBR_ENUM</tt> values.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>.enums</tt>
</dt>
<dd>
<p>
For enumeration values only, an array of enumeration strings
indexable by enumeration value.
</p>
</dd>
</dl></div>
<h3 id="ca_nothing">Error Code Values</h3><div style="clear:left"></div>
<div class="paragraph"><p>Error code values are used to indicate a success return from <tt>caput</tt> (in
which case <tt>.ok</tt> is <tt>True</tt>), to indicated disconnection using <tt>camonitor</tt>, and
to indicate any other failure, either as a return value or raised as an
exception.</p></div>
<div class="paragraph"><p>All error code values have type <tt>ca_nothing</tt> and provide the following fields:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>.ok</tt>
</dt>
<dd>
<p>
Set to <tt>True</tt> if the data is good, <tt>False</tt> if there was an error.  Testing an
error code value for boolean will return the value of <tt>.ok</tt>, so for example it
is possible to write:
</p>
<div class="listingblock">
<div class="content">
<pre><tt>if not caput(pv, value, throw=False):
    process caput error</tt></pre>
</div></div>
</dd>
<dt class="hdlist1">
<tt>.name</tt>
</dt>
<dd>
<p>
Name of the PV which generated this error..
</p>
</dd>
<dt class="hdlist1">
<tt>.errorcode</tt>
</dt>
<dd>
<p>
Channel access error code.  The following values are worth noting:
</p>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>ECA_SUCCESS</tt>
</dt>
<dd>
<p>
Success error code.  In this case <tt>.ok</tt> is <tt>True</tt>.  Returned
by successful <tt>caput</tt> and <tt>connect</tt> calls.
</p>
</dd>
<dt class="hdlist1">
<tt>ECA_DISCONN</tt>
</dt>
<dd>
<p>
Channel disconnected.  This is used by <tt>canotify</tt> to report
channel disconnect events.
</p>
</dd>
<dt class="hdlist1">
<tt>ECA_TIMEOUT</tt>
</dt>
<dd>
<p>
Channel timed out.  Reported if user specified timeout
ocurred before completion and if <tt>throw=False</tt> specified.
</p>
</dd>
</dl></div>
</dd>
</dl></div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated 2011-10-26 14:31:02 BST
</div>
</div>
</body>
</html>
