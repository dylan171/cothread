<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.2.6" />
<style type="text/css">
/* Debug borders */
p, li, dt, dd, div, pre, h1, h2, h3, h4, h5, h6 {
/*
  border: 1px solid red;
*/
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

tt {
  color: navy;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  font-family: sans-serif;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}

div.sectionbody {
  font-family: serif;
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}

pre {
  padding: 0;
  margin: 0;
}

span#author {
  color: #527bbd;
  font-family: sans-serif;
  font-weight: bold;
  font-size: 1.1em;
}
span#email {
}
span#revision {
  font-family: sans-serif;
}

div#footer {
  font-family: sans-serif;
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
div#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
div#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

div#preamble,
div.tableblock, div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-right: 10%;
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.5em;
  margin-bottom: 2.5em;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-family: sans-serif;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid silver;
  padding: 0.5em;
}

div.listingblock {
  margin-right: 0%;
}
div.listingblock > div.content {
  border: 1px solid silver;
  background: #f4f4f4;
  padding: 0.5em;
}

div.quoteblock > div.content {
  padding-left: 2.0em;
}

div.attribution {
  text-align: right;
}
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 2px solid silver;
}

div.exampleblock > div.content {
  border-left: 2px solid silver;
  padding: 0.5em;
}

div.verseblock div.content {
  white-space: pre;
}

div.imageblock div.content { padding-left: 0; }
div.imageblock img { border: 1px solid silver; }
span.image img { border-style: none; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
div.olist > ol {
  list-style-type: decimal;
}
div.olist2 > ol {
  list-style-type: lower-alpha;
}

div.tableblock > table {
  border: 3px solid #527bbd;
}
thead {
  font-family: sans-serif;
  font-weight: bold;
}
tfoot {
  font-weight: bold;
}

div.hlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hlist td {
  padding-bottom: 15px;
}
td.hlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
}
td.hlist2 {
  vertical-align: top;
}

@media print {
  div#footer-badges { display: none; }
}

div#toctitle {
  color: #527bbd;
  font-family: sans-serif;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}
/* Workarounds for IE6's broken and incomplete CSS2. */

div.sidebar-content {
  background: #ffffee;
  border: 1px solid silver;
  padding: 0.5em;
}
div.sidebar-title, div.image-title {
  color: #527bbd;
  font-family: sans-serif;
  font-weight: bold;
  margin-top: 0.0em;
  margin-bottom: 0.5em;
}

div.listingblock div.content {
  border: 1px solid silver;
  background: #f4f4f4;
  padding: 0.5em;
}

div.quoteblock-content {
  padding-left: 2.0em;
}

div.exampleblock-content {
  border-left: 2px solid silver;
  padding-left: 0.5em;
}

/* IE6 sets dynamically generated links as visited. */
div#toc a:visited { color: blue; }

/* Because IE6 child selector is broken. */
div.olist2 ol {
  list-style-type: lower-alpha;
}
div.olist2 div.olist ol {
  list-style-type: decimal;
}
</style>
<title>Using the catools Library</title>
</head>
<body>
<div id="header">
<h1>Using the catools Library</h1>
<span id="author">Michael Abbott</span><br />
</div>
<div id="preamble">
<div class="sectionbody">
<div class="para"><p>Related documentation: <a href="cothread.html">Cothread Library</a>, back to
<a href="index.html">Index Page</a>.</p></div>
</div>
</div>
<h2 id="_overview">Overview</h2>
<div class="sectionbody">
<div class="para"><p>The <tt>catools</tt> library provides the following functions for access to EPICS
&#8220;process variables&#8221; over channel access:</p></div>
<div class="vlist"><dl>
<dt>
<tt>caget(pvs, &#8230;)</tt>
</dt>
<dd>
<p>
Returns a single snapshot of the current value of each PV.
</p>
</dd>
<dt>
<tt>caput(pvs, values, &#8230;)</tt>
</dt>
<dd>
<p>
Writes values to one or more PVs.
</p>
</dd>
<dt>
<tt>camonitor(pvs, callback, &#8230;)</tt>
</dt>
<dd>
<p>
Receive notification each time any of the listed PVs changes.
</p>
</dd>
<dt>
<tt>connect(pvs, &#8230;)</tt>
</dt>
<dd>
<p>
Can be used to establish a connection to a list of PVs before calling the
other routines.  This routine is optional.
</p>
</dd>
</dl></div>
<div class="para"><p>To use these functions a certain amount of setup work is required.  The
following code illustrates a simple application which reads a value from one
PV, writes to another PV, and monitors a third until terminated with
control-C.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt># Library version specification required for dls libraris
from pkg_resources import require
require('numpy==1.1.0')
require('cothread')

import cothread
from cothread.catools import *

# Using caput: write 1234 into PV1.  Raises exception on failure
caput('PV1', 1234)

# Print out the value reported by PV2.
print caget('PV2')

# Monitor PV3, printing out each update as it is received.
def callback(value):
    print 'callback', value
camonitor('PV3', callback)

# Now run the camonitor process until interrupted by Ctrl-C.
cothread.WaitForQuit()</tt></pre>
</div></div>
<div class="para"><p>The following details are general to all cothread applications.</p></div>
<div class="olist"><ol>
<li>
<p>
The routine <tt>pkg_resources.require()</tt> must be used to specify a particular
version of the library to use.  The <tt>catools</tt> submodule also depends on
<tt>numpy</tt> and this should also be specified, thus the following lines are
required at the start of any catools application:
</p>
<div class="listingblock">
<div class="content">
<pre><tt>from pkg_resources import require
require('numpy==1.1.0')
require('cothread==1.9')</tt></pre>
</div></div>
<div class="para"><p>or if the most recent version is ok then the version number can be omitted as
in the example.</p></div>
</li>
<li>
<p>
Any <tt>EPICS_CA_</tt> environment variables should be set at this point, before
importing <tt>catools</tt> (see <a href="#environment">below</a>).
</p>
</li>
<li>
<p>
Of course, the libraries must be imported.  The <tt>catools</tt> library is a
sub-module of the <tt>cothread</tt> library, and can be imported separately.
</p>
</li>
<li>
<p>
If <tt>camonitor</tt> is being used then the program should suspend in an event
loop of some sort.  The routine <tt>cothread.WaitForQuit()</tt> can be used, as
otherwise the <tt>camonitor</tt> activity has no opportunity to run before the
program exits!
</p>
</li>
</ol></div>
</div>
<h2 id="_tips_and_tricks">Tips and Tricks</h2>
<div class="sectionbody">
<div class="para"><p>The following notes may be helpful when using this library.</p></div>
<h3 id="environment">Environment Variables</h3><div style="clear:left"></div>
<div class="para"><p>A number of environment variables affect the operation of channel access.
These can be set using the <tt>os.environ</tt> dictionary &#8212; but note that these
need to be set <em>before</em> loading the <tt>catools</tt> module.  The following are
documented in the
<a href="http://www.aps.anl.gov/epics/EpicsDocumentation/AppDevManuals/ChannelAccess/cadoc_4.htm">
EPICS channel access developers manual</a>.</p></div>
<div class="hlist"><table>
<tr>
<td class="hlist1">
<tt>EPICS_CA_MAX_ARRAY_BYTES</tt>
</td>
<td class="hlist2">
Configures the maximum number of bytes that can be
transferred in a single channel access message.
</td>
</tr>
<tr>
<td class="hlist1">
<tt>EPICS_CA_ADDR_LIST</tt>
</td>
<td class="hlist2">
A space separated list of channel access server
addresses.
</td>
</tr>
<tr>
<td class="hlist1">
<tt>EPICS_CA_AUTO_ADDR_LIST</tt>
</td>
<td class="hlist2">
If set to &#8220;NO&#8221; the automatic scanning of
networks is disabled.
</td>
</tr>
<tr>
<td class="hlist1">
<tt>EPICS_CA_CONN_TMO</tt>
</td>
<td class="hlist2">
Connection timeout, 30 seconds by default.
</td>
</tr>
<tr>
<td class="hlist1">
<tt>EPICS_CA_BEACON_PERIOD</tt>
</td>
<td class="hlist2">
Beacon polling period, 15 seconds by default.
</td>
</tr>
<tr>
<td class="hlist1">
<tt>EPICS_CA_SERVER_PORT</tt>, <tt>EPICS_CA_REPEATER_PORT</tt>
</td>
<td class="hlist2">
Set these to configure the
ports used to connect to channel access.  By default ports 5064 and 5065 are
used (respectively); for testing we use 6064 and 6065.
</td>
</tr>
</table></div>
<div class="para"><p>Example code:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>import os
os.environ['EPICS_CA_MAX_ARRAY_BYTES'] = '1000000'

# Note: the first import of catools must come after the environ is set up.
from cothread.catools import *</tt></pre>
</div></div>
</div>
<h2 id="_function_reference">Function Reference</h2>
<div class="sectionbody">
<div class="para"><p>The <tt>catools</tt> API consists of the three functions <tt>caput</tt>, <tt>caget</tt> and
<tt>camonitor</tt>.  The functions <tt>caget</tt> and <tt>camonitor</tt> return or deliver
&#8220;augmented&#8221; values which are documented in more detail in the section
<a href="#Values">Working with Values</a> below.</p></div>
<h3 id="Common">Common Notes</h3><div style="clear:left"></div>
<div class="para"><p>All three arguments take an argument <tt>pvs</tt> which can specify the name of a
single PV or can be a list of PVs.  In all cases the returned result has the
same &#8220;shape&#8221; as the <tt>pvs</tt> argument, in other words, if <tt>pvs</tt> is a single
string then a single value (error code, value, or subscription) is returned,
and if <tt>pvs</tt> is a list then a list of exactly the same length is returned.</p></div>
<div class="para"><p>In general there are advantages to calling <tt>caput</tt> or <tt>caget</tt> on a list of
PVs, as in this case the channel access delays will occur in parallel.</p></div>
<div class="para"><p>Several arguments are common among at least two functions: <tt>throw</tt> determines
how errors are handled, <tt>timeout</tt> determines timeouts, and finally <tt>datatype</tt>,
<tt>format</tt> and <tt>count</tt> determine data formats and are documented in <a href="#Augmented">Augmented Values</a>.</p></div>
<div class="vlist"><dl>
<dt>
<tt>timeout</tt>
</dt>
<dd>
<p>
The <tt>timeout</tt> argument specified how long <tt>caput</tt> or <tt>caget</tt> will wait for the
entire operation to complete.  This timeout is in seconds, and can be one of
several formats: a timeout interval in seconds, an absolute deadline (in
<tt>time()</tt> format) as a single element tuple, or None to specify that no timeout
will occur.  Note that a timeout of 0 will timeout immediately if any waiting
is required.
</p>
<div class="para"><p>If a timeout occurs then a <tt>Timedout</tt> exception will be raised unless
<tt>throw=False</tt> has been set.</p></div>
</dd>
<dt>
<tt>throw</tt>
</dt>
<dd>
<p>
This parameter determines the behaviour of <tt>caget</tt> and <tt>caput</tt> when an error
occurs.  If <tt>throw=True</tt> (the default) is set then an exception is raised,
otherwise if <tt>False</tt> is specified an error code value is returned for each
failing PV.
</p>
</dd>
</dl></div>
<h3 id="_functions">Functions</h3><div style="clear:left"></div>
<div class="vlist"><dl>
<dt>
<tt>caput(pvs, values, repeat_value=False, timeout=5, wait=False, throw=True)</tt>
</dt>
<dd>
<p>
Writes values to one or more PVs.  If <tt>pvs</tt> is a single string then <tt>values</tt>
is treated as a single value to be written to the named process variable,
otherwise <tt>pvs</tt> must be iterable, and unless <tt>repeat_value=True</tt> is set,
<tt>values</tt> must also be an iterable of the same length in which case
<tt>values[i]</tt> is written to <tt>pvs[i]</tt>.  Otherwise, if a single value is given or
if <tt>repeat_value=True</tt> is specified, <tt>values</tt> is written to all PVs.
</p>
<div class="para"><p>The arguments control the behavour of caput as follows:</p></div>
<div class="vlist"><dl>
<dt>
<tt>repeat_value</tt>
</dt>
<dd>
<p>
When writing a value to a list of PVs ensures that <tt>values</tt> is treated as a
single value to be written to each PV.
</p>
</dd>
<dt>
<tt>wait</tt>
</dt>
<dd>
<p>
If <tt>wait=True</tt> is specified then channel access put with callback is
invoked, and the <tt>caput</tt> operation will wait until the server
acknowledges successful completion before returning.
</p>
</dd>
<dt>
<tt>timeout</tt>, <tt>throw</tt>
</dt>
<dd>
<p>
Documented in <a href="#Common">Common Notes</a> above.
</p>
</dd>
</dl></div>
<div class="para"><p>The return value from <tt>caput</tt> is either a list or a single value, depending on
the shape of <tt>pvs</tt>.  For each PV a <tt>ca_nothing</tt> success code is
returned on success, otherwise either an exception is raised or an appropriate
error code is returned for each failing PV if <tt>throw=True</tt> is set.  The return
code can be tested for boolean success, so for example it
is possible to write:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>if not caput(pv, value, throw=False):
    # process caput error</tt></pre>
</div></div>
<div class="para"><p>If all the PVs listed in <tt>pvs</tt> have already been connected, through a
successful call to any <tt>catools</tt> method, then the library guarantees that the
puts for each PV will occur strictly in sequence.  For any PVs which need a
connection to be established the order of execution of puts is completely
undefined.</p></div>
</dd>
<dt>
<tt>caget(pvs, timeout=5, datatype=None, format=FORMAT_RAW, count=0, throw=True)</tt>
</dt>
<dd>
<p>
Retrieves a value from one or more PVs.  If <tt>pvs</tt> is a single string then
a single value is returned, otherwise a list of values is returned.  Each
value returned is an <a href="#Augmented">Augmented Value</a>, see
below for details.
</p>
<div class="para"><p>If <tt>.ok</tt> is <tt>False</tt> then the <tt>.errorcode</tt> field is set to the appropriate
<tt>ECA_</tt> error code and <tt>str(value)</tt> will return an error message.</p></div>
<div class="para"><p>The various arguments control the behaviour of <tt>caget</tt> as follows:</p></div>
<div class="vlist"><dl>
<dt>
<tt>datatype</tt>, <tt>format</tt>, <tt>count</tt>
</dt>
<dd>
<p>
See documentation for <a href="#Augmented">Augmented Values</a> below.
</p>
</dd>
<dt>
<tt>timeout</tt>, <tt>throw</tt>
</dt>
<dd>
<p>
Documented in <a href="#Common">Common Notes</a> above.  If a value cannot be retrieved
and <tt>throw=False</tt> is set then for each failing PV an empty value with
<tt>.ok==False</tt> is returned.
</p>
</dd>
</dl></div>
<div class="para"><p>The format of values returned depends on the number of values requested
for each PV.  If only one value is requested then the value is returned
as a scalar, otherwise as a numpy array.</p></div>
</dd>
<dt>
<tt>camonitor(pvs, callback, events=DBE_VALUE, datatype=None, format=FORMAT_RAW, count=0, all_updates=False, notify_disconnect=False)</tt>
</dt>
<dd>
<p>
Creates a subscription to one or more PVs, returning a subscription
object for each PV.  If a single PV is given then a single subscription
object is returned, otherwise a list of subscriptions is returned.
</p>
<div class="para"><p>Subscriptions will remain active until the <tt>.close()</tt> method is called on
the returned subscription object.</p></div>
<div class="para"><p>The precise way in which the callback routine is called on updates
depends on whether <tt>pvs</tt> is a single name or a list of names.  If it is
single name then it is called as</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>callback(value)</tt></pre>
</div></div>
<div class="para"><p>for each update.  If <tt>pvs</tt> is a list of names then each update is
reported as</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>callback(value, index)</tt></pre>
</div></div>
<div class="para"><p>where <tt>index</tt> is the position in the original array of PVs of the PV
generating this update.  The values passed to <tt>callback</tt> are <a href="#Augmented">Augmented Values</a>.</p></div>
<div class="para"><p>The parameters modify the behaviour as follows:</p></div>
<div class="vlist"><dl>
<dt>
<tt>events</tt>
</dt>
<dd>
<p>
This identifies the type of update which will be notified.  A
bit-wise or of any the following are possible:
</p>
<div class="hlist"><table>
<tr>
<td class="hlist1">
<tt>DBE_VALUE</tt>
</td>
<td class="hlist2">
Notify normal value changes
</td>
</tr>
<tr>
<td class="hlist1">
<tt>DBE_LOG</tt>
</td>
<td class="hlist2">
Notify archive value changes
</td>
</tr>
<tr>
<td class="hlist1">
<tt>DBE_ALARM</tt>
</td>
<td class="hlist2">
Notify alarm state changes
</td>
</tr>
</table></div>
</dd>
<dt>
<tt>datatype</tt>, <tt>format</tt>, <tt>count</tt>
</dt>
<dd>
<p>
See documentation for <a href="#Augmented">Augmented Values</a> below.
</p>
</dd>
<dt>
<tt>all_updates</tt>
</dt>
<dd>
<p>
If this is <tt>True</tt> then every update received from channel access will
be delivered to the callback, otherwise multiple updates received
between callback queue dispatches will be merged into the most recent
value.
</p>
<div class="para"><p>If updates are being merged then the value returned will be
augmented with a field <tt>.update_count</tt> recording how many updates
occurred on this value.</p></div>
</dd>
<dt>
<tt>notify_disconnect</tt>
</dt>
<dd>
<p>
If this is <tt>True</tt> then IOC disconnect events and channel access
error reports will be reported by calling the callback with a <tt>ca_nothing</tt>
error with <tt>.ok</tt> False.  By default <tt>False</tt> these notifications are
suppressed so that only valid values will be passed to the callback routine.
</p>
</dd>
</dl></div>
</dd>
<dt>
<tt>connect(pvs, wait=True, timeout=5, throw=True)</tt>
</dt>
<dd>
<p>
Establishes a connection to one or more PVs.  A single PV or a list of PVs
can be given.  This does not normally need to be called, as the <tt>ca&#8230;()</tt>
routines will establish their own connections as required, but after a
successful connection we can guarantee that <tt>caput(&#8230;, wait=False)</tt> will
complete immediately without suspension and that <tt>caput(pvs, values)</tt> will
execute in order if all PVs in <tt>pvs</tt> have been successfully connected.
</p>
<div class="para"><p>It is possible to test whether a channel has successfully connected by calling
<tt>connect(pv, wait=True, timeout=0, throw=False)</tt> and testing the result.</p></div>
<div class="para"><p>The various arguments control the behaviour of <tt>connect</tt> as follows:</p></div>
<div class="vlist"><dl>
<dt>
<tt>wait</tt>
</dt>
<dd>
<p>
Normally the connect routine will not return until the requested
connection is established.  If <tt>wait=False</tt> is set then a connection
request will be queued and connect will unconditionally succeed.
</p>
</dd>
<dt>
<tt>timeout</tt>, <tt>throw</tt>
</dt>
<dd>
<p>
Documented in <a href="#Common">Common Notes</a> above.  If a value cannot be retrieved
and <tt>throw=False</tt> is set then for each failing PV an empty value with
<tt>.ok==False</tt> is returned.
</p>
</dd>
</dl></div>
</dd>
</dl></div>
</div>
<h2 id="Values">Working with Values</h2>
<div class="sectionbody">
<div class="para"><p>There are two types of values returned by catools functions: &#8220;augmented
values&#8221; and &#8220;error codes&#8221;.  The <tt>caput</tt> function only returns an error code
value (which may indicate success), while <tt>caget</tt> and <tt>camonitor</tt> will
normally return (or deliver) augmented values, but will return (or deliver) an
error code on failure.</p></div>
<div class="para"><p>The following fields are common to both types of value.  This means that is is
always safe to test <tt>value.ok</tt> for a value returned by <tt>caget</tt> or <tt>caput</tt> or
deliverd by <tt>camonitor</tt>.</p></div>
<div class="vlist"><dl>
<dt>
<tt>.ok</tt>
</dt>
<dd>
<p>
Set to <tt>True</tt> if the data is good, <tt>False</tt> if there was an error.  For
augmented values <tt>.ok</tt> is always set to <tt>True</tt>.
</p>
</dd>
<dt>
<tt>.name</tt>
</dt>
<dd>
<p>
Name of the pv.
</p>
</dd>
</dl></div>
<h3 id="Augmented">Augmented Values</h3><div style="clear:left"></div>
<div class="para"><p>Augmented values are normally Python or <tt>numpy</tt> values with extra fields: the
<tt>.ok</tt> and <tt>.name</tt> fields are already mentioned above, and further extra fields
will be present depending on format requested for the data.  As pointed
out above, <tt>.ok</tt> is always <tt>True</tt>.</p></div>
<div class="para"><p>Four different types of augmented value are returned: strings, integers,
floating point numbers or arrays, depending on the length of the data
requested &#8212; an array is only used when the data length is &gt;1.</p></div>
<div class="para"><p>In almost all circumstances an augmented value will behave exactly like a
normal value, but there are a few cases where differences in behaviour are
observed (these are mostly bugs).  If this occurs the augumentation can be
stripped from an augmented value <tt>value</tt> by writing <tt>+value</tt> &#8212; this returns
the underlying value.</p></div>
<div class="para"><p>The type of augmented values is determined both by parameters passed to
<tt>caget</tt> and <tt>camonitor</tt> and by the underlying datatype.  Both of these
functions share parameters <tt>datatype</tt>, <tt>format</tt> and <tt>count</tt> which can be used
to force the type of the data returned:</p></div>
<div class="vlist"><dl>
<dt>
<tt>datatype</tt>
</dt>
<dd>
<p>
This controls the format of the data that will be requested.  This
can be any of the following:
</p>
<div class="olist"><ol>
<li>
<p>
<tt>None</tt> (the default).  In this case the &#8220;native&#8221; datatype provided
    by the channel will be returned.
</p>
</li>
<li>
<p>
A <tt>DBR_</tt> value, one of the following:
</p>
<div class="hlist"><table>
<tr>
<td class="hlist1">
<tt>DBR_STRING</tt>
</td>
<td class="hlist2">
Strings are up to 39 characters long &#8212; this is a constraint
set by EPICS.
</td>
</tr>
<tr>
<td class="hlist1">
<tt>DBR_CHAR</tt>, <tt>DBR_SHORT</tt>, <tt>DBR_LONG</tt>
</td>
<td class="hlist2">
These are all signed integer types,
with 8, 16 and 32 bit values respectively.
</td>
</tr>
<tr>
<td class="hlist1">
<tt>DBR_FLOAT</tt>, <tt>DBR_DOUBLE</tt>
</td>
<td class="hlist2">
Floating point values with 32 and 64 bit values,
respectively.
</td>
</tr>
<tr>
<td class="hlist1">
<tt>DBR_ENUM</tt>
</td>
<td class="hlist2">
A 16 bit unsigned integer value representing an index into an
array of strings.  The associated strings can be retrieved by using
<tt>format=FORMAT_CTRL</tt> and inspecting the <tt>.enums</tt> field.
</td>
</tr>
</table></div>
</li>
<li>
<p>
A python type compatible with any of the above values, such as
    <tt>int</tt>, <tt>float</tt> or <tt>str</tt>.  These correspond to <tt>DBR_LONG</tt>, <tt>DBR_DOUBLE</tt> and
    <tt>DBR_STRING</tt> respectively.
</p>
</li>
<li>
<p>
Any <tt>numpy</tt> <tt>dtype</tt> compatible with any of the above values.
</p>
</li>
</ol></div>
</dd>
<dt>
<tt>format</tt>
</dt>
<dd>
<p>
This controls how much auxilliary information will be returned with
the retrieved data, and can be one of the following:
</p>
<div class="vlist"><dl>
<dt>
<tt>FORMAT_RAW</tt> (default)
</dt>
<dd>
<p>
The data is returned unaugmented except for the <tt>.name</tt> and <tt>.ok</tt> fields.
</p>
</dd>
<dt>
<tt>FORMAT_TIME</tt>
</dt>
<dd>
<p>
The data is augmented by timestamp fields <tt>.timestamp</tt> and <tt>.raw_stamp</tt>
together with .<tt>alarm</tt>, <tt>.status</tt> and <tt>.severity</tt> fields.  The value in
<tt>.timestamp</tt> is in <tt>time()</tt> format (seconds in Unix UTC epoch).
</p>
</dd>
<dt>
<tt>FORMAT_CTRL</tt>
</dt>
<dd>
<p>
The data is augmented by channel access &#8220;control&#8221; fields.
</p>
<div class="para"><p>The set of fields returned in <tt>FORMAT_CTRL</tt> depends on the underlying datatype
as follows:</p></div>
<div class="vlist"><dl>
<dt>
<tt>DBR_SHORT</tt>, <tt>DBR_CHAR</tt>, <tt>DBR_LONG</tt>
</dt>
<dd>
<p>
The alarm <tt>.status</tt> and <tt>.severity</tt> fields together with <tt>.units</tt>
and limit fields:
<tt>.upper_disp_limit</tt>, <tt>.lower_disp_limit</tt>,
<tt>.upper_alarm_limit</tt>, <tt>.lower_alarm_limit</tt>,
<tt>.upper_warning_limit</tt>, <tt>.lower_warning_limit</tt>,
<tt>.upper_ctrl_limit</tt>, <tt>.lower_ctrl_limit</tt>.
The meaning of these fields is determined by channel access.
</p>
</dd>
<dt>
<tt>DBR_FLOAT</tt>, <tt>DBR_DOUBLE</tt>
</dt>
<dd>
<p>
As above together with a <tt>.precision</tt> field.
</p>
</dd>
<dt>
<tt>DBR_ENUM</tt>
</dt>
<dd>
<p>
Alarm <tt>.status</tt> and <tt>.severity</tt> fields together with <tt>.enums</tt>, a
list of possible enumeration strings.  The underlying value for an enumeration
will be an index into <tt>.enums</tt>.
</p>
</dd>
<dt>
<tt>DBR_STRING</tt>
</dt>
<dd>
<p>
<tt>_CTRL</tt> format is not supported for this field type, and
<tt>FORMAT_TIME</tt> data is returned instead.
</p>
</dd>
</dl></div>
</dd>
</dl></div>
</dd>
<dt>
<tt>count</tt>
</dt>
<dd>
<p>
If specified this can be used to limit the number of waveform points
retrieved from the server, otherwise the entire waveform is always returned.
</p>
</dd>
</dl></div>
<h4 id="_fields">Fields</h4>
<div class="para"><p>Summary of all available fields in augmented values.</p></div>
<div class="para"><p>The following fields are present in all augmented values.</p></div>
<div class="hlist"><table>
<tr>
<td class="hlist1">
<tt>.name</tt>
</td>
<td class="hlist2">
Name of record, always present.
</td>
</tr>
<tr>
<td class="hlist1">
<tt>.ok</tt>
</td>
<td class="hlist2">
Set to <tt>True</tt>, always present.
</td>
</tr>
</table></div>
<div class="para"><p>The following fields are present in all values if <tt>FORMAT_TIME</tt> is specified.</p></div>
<div class="hlist"><table>
<tr>
<td class="hlist1">
<tt>.raw_stamp</tt>
</td>
<td class="hlist2">
Record timestamp in raw format as provided by EPICS (but in the
local Unix epoch, not the EPICS epoch).  Is a tuple of the form <tt>(secs, nsec)</tt>
with integer seconds and nanosecond values, provided in case full ns timestamp
precision is required.
</td>
</tr>
<tr>
<td class="hlist1">
<tt>.timestamp</tt>
</td>
<td class="hlist2">
Timestamp in seconds in format compatible with <tt>time.time()</tt>
rounded to the nearest microsecond: for nanosecond precision use <tt>.raw_stamp</tt>
instead.
<div class="para"><p>To compute the timestamp in <tt>datetime</tt> format, which can be more suitable for
display applications, it can be added to the value by computing</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>import datetime
value.datetime = datetime.datetime.fromtimestamp(value.timestamp)</tt></pre>
</div></div>
</td>
</tr>
</table></div>
<div class="para"><p>The following fields are present in all values if <tt>FORMAT_TIME</tt> or
<tt>FORMAT_CTRL</tt> is specified.</p></div>
<div class="hlist"><table>
<tr>
<td class="hlist1">
<tt>.severity</tt>
</td>
<td class="hlist2">
EPICS alarm severity, normally one of the values listed below.
<div class="sidebarblock">
<div class="sidebar-content">
<div class="hlist"><table>
<tr>
<td class="hlist1">
0
</td>
<td class="hlist2">
&#8658; No alarm
</td>
</tr>
<tr>
<td class="hlist1">
1
</td>
<td class="hlist2">
&#8658; Alarm condition, minor severity
</td>
</tr>
<tr>
<td class="hlist1">
2
</td>
<td class="hlist2">
&#8658; Alarm condition, major severity.
</td>
</tr>
<tr>
<td class="hlist1">
3
</td>
<td class="hlist2">
&#8658; Invalid value.
</td>
</tr>
</table></div>
</div></div>
</td>
</tr>
<tr>
<td class="hlist1">
<tt>.status</tt>
</td>
<td class="hlist2">
Reason code associated with alarm severity, always present with
<tt>.severity</tt> code.
</td>
</tr>
</table></div>
<div class="para"><p>The following fields are present in numeric values if <tt>FORMAT_CTRL</tt> is
specified.  Values of type <tt>DBR_ENUM</tt> or <tt>DBR_STRING</tt> are not numeric.</p></div>
<div class="hlist"><table>
<tr>
<td class="hlist1">
<tt>.units</tt>
</td>
<td class="hlist2">
Units for display.
</td>
</tr>
<tr>
<td class="hlist1">
<tt>.upper_disp_limit</tt>, <tt>.lower_disp_limit</tt>
</td>
<td class="hlist2">
Suggested display limits for
numerical values.
</td>
</tr>
<tr>
<td class="hlist1">
<tt>.upper_alarm_limit</tt>, <tt>.lower_alarm_limit</tt>, <tt>.upper_warning_limit</tt>, <tt>.lower_warning_limit</tt>, <tt>.upper_ctrl_limit</tt>, <tt>.lower_ctrl_limit</tt>
</td>
<td class="hlist2">
These are all mystery EPICS numeric limits.  If somebody knows what they mean,
please update this documentation accordingly!
</td>
</tr>
<tr>
<td class="hlist1">
<tt>.precision</tt>
</td>
<td class="hlist2">
For floating point values only, the specified display precision
(or 0 if not specified).  Present if value is a floating point type.
</td>
</tr>
</table></div>
<div class="para"><p>The following field is only present in <tt>DBR_ENUM</tt> values.</p></div>
<div class="hlist"><table>
<tr>
<td class="hlist1">
<tt>.enums</tt>
</td>
<td class="hlist2">
For enumeration values only, an array of enumeration strings.
</td>
</tr>
</table></div>
<h3 id="ca_nothing">Error Code Values</h3><div style="clear:left"></div>
<div class="para"><p>Error code values are used to indicate a success return from <tt>caput</tt> (in
which case <tt>.ok</tt> is <tt>True</tt>), to indicated disconnection using <tt>camonitor</tt>, and
to indicate any other failure, either as a return value or raised as an
exception.</p></div>
<div class="para"><p>All error code values have type <tt>ca_nothing</tt> and provide the following fields:</p></div>
<div class="vlist"><dl>
<dt>
<tt>.ok</tt>
</dt>
<dd>
<p>
Set to <tt>True</tt> if the data is good, <tt>False</tt> if there was an error.  Testing an
error code value for boolean will return the value of <tt>.ok</tt>, so for example it
is possible to write:
</p>
<div class="listingblock">
<div class="content">
<pre><tt>if not caput(pv, value, throw=False):
    process caput error</tt></pre>
</div></div>
</dd>
<dt>
<tt>.name</tt>
</dt>
<dd>
<p>
Name of the PV which generated this error..
</p>
</dd>
<dt>
<tt>.errorcode</tt>
</dt>
<dd>
<p>
Channel access error code.  The following values are worth noting:
</p>
<div class="hlist"><table>
<tr>
<td class="hlist1">
<tt>ECA_SUCCESS</tt>
</td>
<td class="hlist2">
Success error code.  In this case <tt>.ok</tt> is <tt>True</tt>.
</td>
</tr>
<tr>
<td class="hlist1">
<tt>ECA_DISCONN</tt>
</td>
<td class="hlist2">
Channel disconnected.  This is used by <tt>canotify</tt> to report
channel disconnect events.
</td>
</tr>
<tr>
<td class="hlist1">
<tt>ECA_TIMEOUT</tt>
</td>
<td class="hlist2">
Channel timed out.  Reported if user specified timeout
ocurred before completion and if <tt>throw=False</tt> specified.
</td>
</tr>
</table></div>
</dd>
</dl></div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2009-07-10 11:38:19 BST
</div>
</div>
</body>
</html>
