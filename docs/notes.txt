Cothread Architecture Notes
===========================

Some notes on key architectural issues in the `cothread` scheduler.


Coroutine Switching
-------------------

There are precisely 7 calls to `switch` in the `cothread` library, and it's
crucial that they work together correctly.  These calls are (in order of
appearance in the code).

. During scheduler creation (in the `.create` method of `_Scheduler`) we
create a separate scheduler task and switch to that.  This should be called
from the main parent task (ie, when it ends, the application terminates).

. As soon as the scheduler has been initialised, control is returned to the
main task.  This is in `.\_\_scheduler`, which carries a top level loop for
restarting the scheduler.

. If the main scheduler loop `.\_\_schedule_loop` raises an exception, control
is switched to the main parent task with a special `.\_\_WAKEUP_INTERRUPT`
return code.  The main task will at this point normally be waiting for a
normal scheduler wake up.

. The `.\_\_tick` dispatcher switches to all ready tasks in turn passing a
wakeup code, either `.\_\_WAKEUP_NORMAL` or `.\_\_WAKEUP_TIMEOUT`.

. If `.poll_scheduler` has been called, and thus `.\_\_poll_callback` is set,
the routine `.\_\_poll_suspend` will switch back to the suspended
`.poll_scheduler` call.  In this case special polling arguments are passed
(this should be a list of (descriptor, flags) pairs, together with a timeout),
and a list of active descriptors should be returned.

. `.poll_scheduler` defines the other side of this switch: a list of ready
descriptors is passed in a switch to the scheduler task, and the polling
arguments described above are returned from the `.poll_scheduler` call --
unless a `.\_\_WAKEUP_INTERRUPT` switch has occurred!

. The normal place where control is switched to the scheduler is in the middle
of `.wait_until`.  We have to pass an empty list (to be compatible with the
`.poll_scheduler` switch), and a wakeup reason should be returned.
