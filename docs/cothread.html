<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.5.2" />
<title>Using the cothread and catools Library</title>
<style type="text/css">
/* Debug borders */
p, li, dt, dd, div, pre, h1, h2, h3, h4, h5, h6 {
/*
  border: 1px solid red;
*/
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

tt {
  color: navy;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  font-family: sans-serif;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}

div.sectionbody {
  font-family: serif;
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}

pre {
  padding: 0;
  margin: 0;
}

span#author {
  color: #527bbd;
  font-family: sans-serif;
  font-weight: bold;
  font-size: 1.1em;
}
span#email {
}
span#revnumber, span#revdate, span#revremark {
  font-family: sans-serif;
}

div#footer {
  font-family: sans-serif;
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
div#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
div#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

div#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.tableblock, div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-family: sans-serif;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid silver;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid silver;
  background: #f4f4f4;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #dddddd;
  color: #777777;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > div.content {
  white-space: pre;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-family: sans-serif;
  font-weight: bold;
}
tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}


@media print {
  div#footer-badges { display: none; }
}

div#toc {
  margin-bottom: 2.5em;
}

div#toctitle {
  color: #527bbd;
  font-family: sans-serif;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}
/* Workarounds for IE6's broken and incomplete CSS2. */

div.sidebar-content {
  background: #ffffee;
  border: 1px solid silver;
  padding: 0.5em;
}
div.sidebar-title, div.image-title {
  color: #527bbd;
  font-family: sans-serif;
  font-weight: bold;
  margin-top: 0.0em;
  margin-bottom: 0.5em;
}

div.listingblock div.content {
  border: 1px solid silver;
  background: #f4f4f4;
  padding: 0.5em;
}

div.quoteblock-attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock-content {
  white-space: pre;
}
div.verseblock-attribution {
  padding-top: 0.75em;
  text-align: left;
}

div.exampleblock-content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

/* IE6 sets dynamically generated links as visited. */
div#toc a:visited { color: blue; }
</style>
<script type="text/javascript">
/*<![CDATA[*/
window.onload = function(){asciidoc.footnotes();}
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([2-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  var cont = document.getElementById("content");
  var noteholder = document.getElementById("footnotes");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      // Use [\s\S] in place of . so multi-line matches work.
      // Because JavaScript has no s (dotall) regex flag.
      note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      spans[i].innerHTML =
        "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
        "' title='View footnote' class='footnote'>" + n + "</a>]";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
}

}
/*]]>*/
</script>
</head>
<body>
<div id="header">
<h1>Using the cothread and catools Library</h1>
<span id="author">Michael Abbott</span><br />
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph"><p>The <tt>cothread</tt> Python library is designed for building tools using cooperative
threading.  This means that, with care, programs can effectively run several
tasks simultaneously.</p></div>
<div class="paragraph"><p>The <tt>cothread.catools</tt> library is designed to support easy channel access from
Python, and makes essential use of the features of cooperative threads&#8201;&#8212;&#8201;in
particular, <tt>camonitor</tt> notifies updates in the background.</p></div>
<div class="paragraph"><p>Related documentation: <a href="catools.html">Channel Access Library</a>, back to
<a href="index.html">Index Page</a>.</p></div>
</div>
</div>
<h2 id="_introduction_to_cothreads">Introduction to Cothreads</h2>
<div class="sectionbody">
<div class="paragraph"><p>Cothreads (or &#8220;cooperative threads&#8221;) are an approach to concurrent
programming where there is only one true thread of processing, but apparently
concurrent processes (or <em>cothreads</em>) can cooperatively share the processor.
Control is passed from one cothread to another when the current cothread
explicitly suspends control, ultimately via a call to a <tt>cothread</tt> library
routine.  This means that between such suspending calls control will not be
interrupted.  This has two advantages:</p></div>
<div class="ulist"><ul>
<li>
<p>
No locking between threads is required.  This is a very helpful benefit of
using cothreads, as getting locking between multiple threads right can be
suprisingly difficult.
</p>
</li>
<li>
<p>
The thread of processing is frequently more predictable: between two
suspension points there is no possibility of unexpected background activity!
</p>
</li>
</ul></div>
<div class="paragraph"><p>On the other hand, there is one disadvantage which needs to be kept in mind:</p></div>
<div class="ulist"><ul>
<li>
<p>
If a cothread blocks (for example, by calling <tt>time.sleep()</tt> or reading from
a socket or remote file without first calling a select function) then <em>all</em>
cothreads will be blocked.  The cothread library provides routines to help
with this (see <tt>Sleep</tt> and <tt>select</tt> below).
</p>
</li>
</ul></div>
<div class="paragraph"><p>To use the <tt>cothread</tt> library the following overall structure should be
followed in the top level application:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt># First the version of cothread library must be specified
from pkg_resources import require
require('cothread==2.0')    # or just require('cothread')

# Import the cothread library in each module that uses it.
import cothread

# Enable Qt processing, hang onto application instance if needed.
qtapp = cothread.iqt()

# Do the real work of the module, including spawning any background tasks.
...

# Finally allow all background tasks to run to completion.
cothread.WaitForQuit()</tt></pre>
</div></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
<tt>require('cothread==2.0')</tt>.  This statement is required by the way Diamond
Controls modules are managed: it is necessary to specify precisely <em>which</em>
version of a module is to be used.  This means that API changes can be made in
future releases without breaking existing code.
</p>
<div class="paragraph"><p>Alternatively <tt>require('cothread')</tt> can be used to request the most recent
installed version.</p></div>
<div class="paragraph"><p>Note that the <tt>require</tt> statements should only occur once in each application:
it is an easy mistake to place them at the head of each Python module.</p></div>
</li>
<li>
<p>
If Qt is to be used (for any graphical user interface) then the cothread
library needs to be informed: this is done by calling <tt>iqt()</tt> before any work
is done with Qt.  This call ensures that Qt processing will occur while the
cothread scheduler is idle, and effectively turns Qt into another cothread.
The Qt application instance is created by this call and returned.
</p>
</li>
<li>
<p>
Finally the main cothread (the thread of control used to start and run the
program) must not exit until the program has finished.  If all the desired
activity is in background tasks (spawned cothreads, <tt>camonitor</tt> processing or
other background activity) then the simplest thing is to call <tt>WaitForQuit()</tt>
before exiting: this will wait until the <tt>Quit</tt> function is called, or
control-C is pressed somewhere, or the last Qt window is closed.
</p>
</li>
</ol></div>
<h3 id="_cothread_suspension_points">Cothread Suspension Points</h3><div style="clear:left"></div>
<div class="paragraph"><p>When using cothreads only certain function calls will cause control to be
yielded to another cothread, or in other words, will cause suspension of the
calling cothread&#8201;&#8212;&#8201;we call such a routine a &#8220;suspension point&#8221;.</p></div>
<div class="paragraph"><p>Understanding suspension points is important for effective use of cothreads:
between suspension points no other cothread will run, and the current cothread
has exclusive control of the process (except for any &#8220;real&#8221; threads that
might be running).  Once a suspension point is reached any other cothread can
run, in fact typically <em>all</em> other ready cothreads will run to their own
suspension points before control is returned to the suspended cothread.</p></div>
<div class="paragraph"><p>The following are suspension points in the core <tt>cothread</tt> library:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>Sleep</tt>, <tt>SleepUntil</tt>
</dt>
<dd>
<p>
The caller is always suspended, even if the expiry
time has passed, so <tt>Sleep(0)</tt> has much the same effect as <tt>Yield()</tt>.
</p>
</dd>
<dt class="hdlist1">
<tt>Yield</tt>
</dt>
<dd>
<p>
This suspends the caller until all other active cothreads have run
to their own suspension points.
</p>
</dd>
<dt class="hdlist1">
event<tt>.Wait</tt>
</dt>
<dd>
<p>
On a <tt>Spawn</tt>, <tt>Event</tt> or <tt>EventQueue</tt> object the <tt>Wait</tt>
method will only suspend the caller if the event object is not yet ready and
any specified timeout has not yet expired.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>The <tt>coselect</tt> module adds the following suspension points:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>select</tt>, <tt>poll</tt>, <tt>poll_list</tt>
</dt>
<dd>
<p>
All of these routines suspend the caller until
at least one file descriptor in a monitored list is ready.  The caller will be
suspended even if the ready condition is already met unless the timeout has
already expired.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>In the <tt>catools</tt> module the following routines can cause suspension (note
that <tt>camonitor</tt> is the only routine guaranteed not to suspend):</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>caget</tt>
</dt>
<dd>
<p>
This always suspends the caller until the requested
channel access data has arrived (or a timeout occurs), the only exception
being if an expired timeout is specified.
</p>
</dd>
<dt class="hdlist1">
<tt>caput</tt>
</dt>
<dd>
<p>
This routine will normally cause the caller to suspend.  To avoid
suspension, only put to one PV, use <tt>wait=False</tt>, and ensure that the channel
is already connected&#8201;&#8212;&#8201;this will be the case if it has already been
successfully used in any <tt>catools</tt> method.
</p>
</dd>
</dl></div>
<h3 id="_order_of_execution">Order of Execution</h3><div style="clear:left"></div>
<div class="paragraph"><p>It is possible to be fairly precise about the order in which certain processes
will occur.</p></div>
<div class="ulist"><ul>
<li>
<p>
Cothreads started by <tt>Spawn</tt> will initially be processed in the order in
which they were created with no other cothreads intervening.
</p>
</li>
<li>
<p>
Cothreads waiting on an event will be woken strictly in the sequence in
which waiting takes place, just so long as no timeout occurs.  Cothreads woken
by timeouts generally execute after all all processing is complete.
</p>
</li>
</ul></div>
<div class="paragraph"><p>This ordering of processing together with the fact that cothreads are only
suspended when control needs to be lost means that certain guarantees about
ordering of processing can be made, in particular see <tt>catools.caput</tt>.</p></div>
<h3 id="_callbacks_and_timers">Callbacks and Timers</h3><div style="clear:left"></div>
<div class="paragraph"><p>Callbacks and timers are also provided through the cothread library, and it&#8217;s
important to understand how they interact with other routines.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Timers
</dt>
<dd>
<p>
Timers are created by the <tt>Timer</tt> function documented below.  The callback
that is invoked as part of the timer is a fresh cothread, spawned when the
timer is created.  This means that the timer callback function can run for as
long as desired without interfering with other timer callbacks (so long as it
suspends regularly, of course!)
</p>
<div class="paragraph"><p>Note however that a timer will not retrigger itself until its current callback
routine completes.</p></div>
</dd>
<dt class="hdlist1">
Callbacks from <tt>camonitor</tt>
</dt>
<dd>
<p>
The callback routines called in response to <tt>camonitor</tt> are all invoked on a
single cothread.  This means that extended processing within a single callback
will prevent any other callbacks from being processed.  To avoid this either
spawn a new cothread to perform further process, or communicate with an
existing separate cothread.
</p>
</dd>
<dt class="hdlist1">
Other callbacks
</dt>
<dd>
<p>
Other callbacks will depend on the library generating them, but it&#8217;s safest to
treat them as &#8220;blocking&#8221; in the sense described above.
</p>
</dd>
</dl></div>
</div>
<h2 id="_cothread_api">Cothread API</h2>
<div class="sectionbody">
<div class="paragraph"><p>The following functions define the basic cothread interface provided by this
module.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>Spawn(function, arguments, raise_on_wait=False, stack_size=0, &#8230;)</tt>
</dt>
<dd>
<p>
A new cooperative thread, or <em>cothread</em>, is created as a call to
<tt>function(arguments)</tt> where <tt>arguments</tt> can be any list of values and keyword
arguments (except for the <tt>raise_on_wait</tt> and <tt>stack_size</tt> arguments).
This routine is not a suspension point.
</p>
<div class="paragraph"><p>This is the fundamental building block of the cothreading library.  It is
quite cheap to spawn fresh cothreads, and so this routine can be used freely.</p></div>
<div class="paragraph"><p>The following arguments are treated specially by this routine:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>raise_on_wait</tt>
</dt>
<dd>
<p>
By default any exception raised by running <tt>function(arguments)</tt> is caught and
reported by a traceback to <tt>stderr</tt>.  If this flag is set then instead the
exception is retained and returned when <tt>Wait</tt> is called.
</p>
</dd>
<dt class="hdlist1">
<tt>stack_size</tt>
</dt>
<dd>
<p>
If a non-zero <tt>stack_size</tt> is specified the new cothread is allocated its own
stack, otherwise it will share the main process stack.  The tradeoffs involved
in whether to allocate a stack are subtle.  By default it is safest to leave
this parameter unset.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>It is possible to wait for the completion of a spawned cothread by calling its
<tt>Wait</tt> method:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>Wait(timeout=None)</tt>
</dt>
<dd>
<p>
This blocks until the spawned cothread completes, either by returning from its
function call, or by raising an exception.  If the cothread was created with
<tt>raise_on_wait</tt> set to <tt>True</tt> then any exception raised by the cothread will
be re-raised when <tt>Wait</tt> is called.
</p>
</dd>
</dl></div>
</dd>
<dt class="hdlist1">
<tt>Sleep(delay)</tt>, <tt>SleepUntil(time)</tt>
</dt>
<dd>
<p>
The calling task is suspended until the given time.  <tt>Sleep(delay)</tt>
suspends the task for at least delay seconds, <tt>SleepUntil(time)</tt>
suspends until the specified time has passed (<tt>time</tt> is defined as the
value returned by <tt>time.time()</tt>).
</p>
</dd>
<dt class="hdlist1">
<tt>Yield(timeout=0)</tt>
</dt>
<dd>
<p>
Yield() suspends control so that all other potentially busy tasks can
run.  Control is not returned to the calling task until all other
active tasks have been processed, or the timeout has expired.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Communication between cothreads is provided by <tt>Event</tt> and <tt>EventQueue</tt>
objects.  An <tt>Event</tt> can hold at most one value (or signal), while an
<tt>EventQueue</tt> can hold a list of unbounded length.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>Event(auto_reset=True)</tt>
</dt>
<dd>
<p>
Event objects are initially created <em>unsignalled</em>.  The <tt>auto_reset</tt> flag
determines whether the signalled state of the event object is persistent, and
determines how many cothreads are woken when <tt>Signal</tt> is called on an event.
The <tt>bool</tt> state of an event object is <tt>True</tt> iff it is signalled.
</p>
<div class="paragraph"><p>The following methods define the behaviour of this object.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>Wait(timeout=None)</tt>
</dt>
<dd>
<p>
The calling cothread will be suspended until a signal is written to the
<tt>Event</tt> by a call to <tt>Signal()</tt>, at which point the value passed to <tt>Signal()</tt>
is returned.  If a timeout occurs (a timeout of <tt>None</tt> specifies no timeout)
this is signalled by raising the exception <tt>Timedout</tt>.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>If <tt>auto_reset</tt> was specified as <tt>True</tt> then the signal is consumed, and
subsequent calls to <tt>Wait</tt> will block until further <tt>Signal</tt> calls occur.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>Signal(value=None)</tt>
</dt>
<dd>
<p>
The event object is marked as signalled and the value passed is recorded to be
returned by a call to <tt>Wait</tt>.  If one or more cothreads are waiting for a
signal then at least one will be woken with the new value (if <tt>auto_reset</tt> is
<tt>True</tt> then only one will be woken, otherwise all will be).
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Note that this routine does <strong>not</strong> suspend the caller, even if another cothread
is woken: it will not process until later.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>SignalException(exception)</tt>
</dt>
<dd>
<p>
This is similar in effect to <tt>Signal</tt>, but the effect on cothreads calling
<tt>Wait</tt> is that they will receive the given exception.
</p>
</dd>
<dt class="hdlist1">
<tt>Reset()</tt>
</dt>
<dd>
<p>
Resets the signal and erases its value.  Also erases any exception written to
the event.
</p>
</dd>
</dl></div>
</dd>
<dt class="hdlist1">
<tt>EventQueue()</tt>
</dt>
<dd>
<p>
The <tt>EventQueue</tt> is designed to support the communication of a stream of
values between two cothreads.  Calling <tt>len()</tt> on an event queue returns the
number of entries currently in its queue.  An event queue can also be consumed
as an iterator, see code example below.
</p>
<div class="paragraph"><p>The following methods are supported:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>Wait(timeout=None)</tt>
</dt>
<dd>
<p>
Returns the next object from the queue, blocking if necessary.  If a timeout
occurs then <tt>Timedout</tt> is raised.  If the queue has been closed then
<tt>StopIteration</tt> is raised.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>If the queue is non empty when <tt>Wait()</tt> is called control will not be
suspended.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>Signal(value)</tt>
</dt>
<dd>
<p>
Adds the given value to the queue, waking up a waiting cothread if one is
waiting.  This routine does not suspend the caller.
</p>
</dd>
<dt class="hdlist1">
<tt>close()</tt>
</dt>
<dd>
<p>
Marks the queue as closed, after which no more signals can be raised.  Calling
<tt>Wait()</tt> on a closed queue will cause <tt>StopIteration</tt> to be raised.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Example code using iteration over an <tt>EventQueue</tt>.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>def consumer(e):
    for x in e:
        print 'consumed', x

eq = EventQueue()
Spawn(consumer, eq)

for i in range(10):
    eq.Signal(i)
    Sleep(1)</tt></pre>
</div></div>
</dd>
<dt class="hdlist1">
<tt>ThreadedEventQueue()</tt>
</dt>
<dd>
<p>
The <tt>ThreadedEventQueue</tt> behaves like an <tt>EventQueue</tt>, but is designed to be
used to communicate between a Python thread outside of the cothread library
and a cothread.  Communication can occur in either direction: an outside
thread can call <tt>Signal</tt> on a threaded event queue while a cothread calls
<tt>Wait</tt>, or vice versa.
</p>
<div class="paragraph"><p>If a thread calls <tt>Wait</tt> it will block until a cothread (or another thread)
calls <tt>Signal</tt>.  If this is undesirable then the field <tt>.wait_descriptor</tt> can
be waited on using the standard <tt>select</tt> or <tt>poll</tt> functions.  Note that this
file handle must <em>only</em> be used for waiting, and must not be read!</p></div>
</dd>
<dt class="hdlist1">
<tt>Timer(timeout, callback, retrigger=False)</tt>
</dt>
<dd>
<p>
This triggers a call to <tt>callback</tt> after a delay of at least <tt>timeout</tt>
seconds.  If <tt>retrigger</tt> is <tt>True</tt> then after <tt>callback</tt> completes the timer
will be reenabled and the cycle will repeat, otherwise only one call will
occur.
</p>
<div class="paragraph"><p>The timer can be cancelled at any time before it has triggered by calling
<tt>.cancel()</tt> on the timer object created by calling <tt>Timer()</tt>.</p></div>
</dd>
<dt class="hdlist1">
<tt>WaitForAll(event_list, timeout=None)</tt>
</dt>
<dd>
<p>
This routine waits for all events in <tt>event_list</tt> to become ready: this is
done by simply iterating through all the events in turn, waiting for them to
complete.  If <tt>timeout</tt> expires then an exception is raised.
</p>
</dd>
<dt class="hdlist1">
<tt>Quit()</tt>, <tt>WaitForQuit(catch_interrupt=True)</tt>
</dt>
<dd>
<p>
The routine <tt>WaitForQuit</tt> blocks until <tt>Quit</tt> is called, or until interrupted
by an exception.  By default (if <tt>catch_interrupt=True</tt> is set) the keyboard
interrupt is silently caught, but still causes <tt>WaitForQuit</tt> to exit.
</p>
<div class="paragraph"><p>This is designed to be used as the final blocking call at the end of the main
program so that other event loops can run.</p></div>
</dd>
<dt class="hdlist1">
<tt>iqt(poll_interval=0.05, use_timer=False)</tt>
</dt>
<dd>
<p>
If Qt is to be used then this routine must be called during initialisation to
enable the Qt event loop.  The Qt application instance is returned.
</p>
<div class="paragraph"><p>The normal Qt event look hook does not work correctly with modal dialogs
(because they run their own message loops)&#8201;&#8212;&#8201;typically either a modal window
will be closed immediately, or else will block the interpreter.  To work
around this, a Qt timer can be used for polling by setting <tt>use_timer</tt> to
<tt>True</tt> in this call.  Note that this is highly experimental, and in particular
modal dialogs do not work properly with <tt>cothread</tt> when using Qt4.</p></div>
</dd>
</dl></div>
<h3 id="_coselect_functions">Coselect Functions</h3><div style="clear:left"></div>
<div class="paragraph"><p>To enable cothreaded access to sockets and other external event generating
sources the <tt>cothread.coselect</tt> library provides coperative implementations of
<tt>select</tt> and <tt>poll</tt> from the Python library <tt>select</tt> module.  This module
provides the following functions.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>select(iwtd, owtd, ewtd, timeout=None)</tt>
</dt>
<dd>
<p>
Cooperative <tt>select</tt> function, interface compatible with the Python library
<tt>select.select</tt> function (though the exceptions raised are different).
</p>
</dd>
<dt class="hdlist1">
<tt>poll()</tt>
</dt>
<dd>
<p>
Cooperative <tt>poll</tt> object, interface compatible with the Python library
<tt>select.poll</tt> object.
</p>
</dd>
<dt class="hdlist1">
<tt>poll_list(event_list, timeout=None)</tt>
</dt>
<dd>
<p>
Simpler function for waiting for one or more events to occur.  This function
is used to implement the more compatible <tt>select</tt> and <tt>poll</tt> interfaces.
</p>
<div class="paragraph"><p>The <tt>event_list</tt> parameter is a list of pairs, each consisting of a waitable
descriptor and an event mask (generated by oring together <tt>POLL&#8230;</tt>
constants).  This routine will cooperatively block until any descriptor
signals a selected event (or any event from <tt>HUP</tt>, <tt>ERR</tt>, <tt>NVAL</tt>) or until
the timeout (in seconds) occurs.</p></div>
</dd>
</dl></div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated 2011-10-26 14:31:02 BST
</div>
</div>
</body>
</html>
