

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>cothread.cothread &mdash; Cothread  documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Cothread  documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">Cothread  documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for cothread.cothread</h1><div class="highlight"><pre>
<span class="c"># This file is part of the Diamond cothread library.</span>
<span class="c">#</span>
<span class="c"># Copyright (C) 2007 James Rowland, 2007-2012 Michael Abbott,</span>
<span class="c"># Diamond Light Source Ltd.</span>
<span class="c">#</span>
<span class="c"># The Diamond cothread library is free software; you can redistribute it</span>
<span class="c"># and/or modify it under the terms of the GNU General Public License as</span>
<span class="c"># published by the Free Software Foundation; either version 2 of the License,</span>
<span class="c"># or (at your option) any later version.</span>
<span class="c">#</span>
<span class="c"># The Diamond cothread library is distributed in the hope that it will be</span>
<span class="c"># useful, but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General</span>
<span class="c"># Public License for more details.</span>
<span class="c">#</span>
<span class="c"># You should have received a copy of the GNU General Public License along</span>
<span class="c"># with this program; if not, write to the Free Software Foundation, Inc., 51</span>
<span class="c"># Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="c">#</span>
<span class="c"># Contact:</span>
<span class="c">#      Dr. Michael Abbott,</span>
<span class="c">#      Diamond Light Source Ltd,</span>
<span class="c">#      Diamond House,</span>
<span class="c">#      Chilton,</span>
<span class="c">#      Didcot,</span>
<span class="c">#      Oxfordshire,</span>
<span class="c">#      OX11 0DE</span>
<span class="c">#      michael.abbott@diamond.ac.uk</span>

<span class="sd">&#39;&#39;&#39;Simple cooperative threading using coroutines.  The following functions</span>
<span class="sd">define the interface provided by this module.</span>

<span class="sd">    Spawn(function, arguments...)</span>
<span class="sd">        A new cooperative thread, or &quot;task&quot;, is created as a call to</span>
<span class="sd">        function(arguments).  Control is not transferred to the task until</span>
<span class="sd">        control is yielded.</span>

<span class="sd">    Sleep(delay)</span>
<span class="sd">    SleepUntil(time)</span>
<span class="sd">        The calling task is suspended until the given time.  Sleep(delay)</span>
<span class="sd">        suspends the task for at least delay seconds, SleepUntil(time)</span>
<span class="sd">        suspends until the specified time has passed (time is defined as the</span>
<span class="sd">        value returned by time.time()).</span>
<span class="sd">            Control is not returned to the calling task until all other</span>
<span class="sd">        active tasks have been processed.</span>

<span class="sd">    Yield()</span>
<span class="sd">        Yield() suspends control so that all other potentially busy tasks can</span>
<span class="sd">        run.</span>

<span class="sd">Instances of the Event object can be used for communication between tasks.</span>
<span class="sd">The following Event object methods are relevant.</span>

<span class="sd">    Wait()</span>
<span class="sd">    Wait(timeout)</span>
<span class="sd">        Waits for the event object to be signalled or for the timeout to</span>
<span class="sd">        expire (if specified).  Returns True if a signal was received, False</span>
<span class="sd">        if a timeout ocurred.</span>

<span class="sd">    Signal()</span>
<span class="sd">        Signals the event object, releasing at least one waiting task.</span>

<span class="sd">Similarly the EventQueue can be used for communication.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="c"># It might be worth taking a close look at:</span>
<span class="c">#   http://wiki.secondlife.com/wiki/Eventlet</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">bisect</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">thread</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_coroutine</span>

<span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;COTHREAD_CHECK_STACK&#39;</span><span class="p">):</span>
    <span class="n">_coroutine</span><span class="o">.</span><span class="n">enable_check_stack</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">coselect</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">&#39;Spawn&#39;</span><span class="p">,</span>            <span class="c"># Spawn new task</span>

    <span class="s">&#39;Sleep&#39;</span><span class="p">,</span>            <span class="c"># Suspend task for given delay</span>
    <span class="s">&#39;SleepUntil&#39;</span><span class="p">,</span>       <span class="c"># Suspend task until specified time</span>
    <span class="s">&#39;Yield&#39;</span><span class="p">,</span>            <span class="c"># Suspend task for immediate resumption</span>

    <span class="s">&#39;Event&#39;</span><span class="p">,</span>            <span class="c"># Event for waiting and signalling</span>
    <span class="s">&#39;EventQueue&#39;</span><span class="p">,</span>       <span class="c"># Queue of objects with event handling</span>
    <span class="s">&#39;ThreadedEventQueue&#39;</span><span class="p">,</span>   <span class="c"># Event queue designed to work with threads</span>
    <span class="s">&#39;WaitForAll&#39;</span><span class="p">,</span>       <span class="c"># Wait for all events to become ready</span>

    <span class="s">&#39;AbsTimeout&#39;</span><span class="p">,</span>       <span class="c"># Converts timeout into absolute deadline format</span>
    <span class="s">&#39;GetDeadline&#39;</span><span class="p">,</span>      <span class="c"># Returns deadline associated with timeout</span>
    <span class="s">&#39;Deadline&#39;</span><span class="p">,</span>         <span class="c"># Converts deadline into timeout format</span>

    <span class="s">&#39;Timedout&#39;</span><span class="p">,</span>         <span class="c"># Timeout exception raised by event waiting</span>

    <span class="s">&#39;Quit&#39;</span><span class="p">,</span>             <span class="c"># Immediate process quit</span>
    <span class="s">&#39;WaitForQuit&#39;</span><span class="p">,</span>      <span class="c"># Wait until Quit() is called</span>

    <span class="s">&#39;Timer&#39;</span><span class="p">,</span>            <span class="c"># One-shot cancellable timer</span>
    <span class="s">&#39;Callback&#39;</span><span class="p">,</span>         <span class="c"># Simple asynchronous synchronisation</span>
<span class="p">]</span>




<span class="k">class</span> <span class="nc">_TimerQueue</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;A timer queue: objects are held on the queue in timeout sequence.&#39;&#39;&#39;</span>

    <span class="c"># The queue is implemented using the bisect function to insert objects</span>
    <span class="c"># into the queue without having to resort the list.  This is cheap and</span>
    <span class="c"># cheerful to implement and runs fast enough.</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># We maintain the list of timeouts and the associated tasks separately</span>
        <span class="c"># so that bisect searching can safely search the timeouts list without</span>
        <span class="c"># trying to compare wakeups.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__timeouts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__wakeups</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__garbage</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">timeout</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Adds value to the queue with the specified timeout.&#39;&#39;&#39;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__timeouts</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__timeouts</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__wakeups</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">timeout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns the timeout of the queue.  Only valid if queue not empty.&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__timeouts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">wake_expired</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect_right</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__timeouts</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">())</span>
        <span class="n">expired</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__wakeups</span><span class="p">[:</span><span class="n">index</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__timeouts</span><span class="p">[:</span><span class="n">index</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__wakeups</span><span class="p">[:</span><span class="n">index</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">expired</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">task</span><span class="o">.</span><span class="n">wakeup</span><span class="p">(</span><span class="n">_WAKEUP_TIMEOUT</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__garbage</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__garbage</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns the number of entries on the queue.&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__timeouts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;This is called to cancel a timeout.  We add this to our garbage</span>
<span class="sd">        count, triggering a garbage collect if appropriate.&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__garbage</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__garbage</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">timeouts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">wakeups</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">task</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__timeouts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__wakeups</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">task</span><span class="o">.</span><span class="n">woken</span><span class="p">():</span>
                    <span class="n">timeouts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
                    <span class="n">wakeups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__timeouts</span> <span class="o">=</span> <span class="n">timeouts</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__wakeups</span> <span class="o">=</span> <span class="n">wakeups</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__garbage</span> <span class="o">=</span> <span class="mi">0</span>


<span class="k">class</span> <span class="nc">_WakeupQueue</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s">&#39;__waiters&#39;</span><span class="p">,</span>        <span class="c"># List of wakeup objects pending wakeup</span>
        <span class="s">&#39;__garbage&#39;</span><span class="p">,</span>        <span class="c"># Count of expired wakeup objects</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># Every time a timeout occurs a waiter is left behind on the timer</span>
        <span class="c"># queue.  We keep count of these as &quot;garbage&quot;, and at the appropriate</span>
        <span class="c"># time we can garbage collect the queue.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__garbage</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waiter</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">waiter</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">wake</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wake_all</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">wake_all</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span><span class="p">:</span>
                    <span class="n">task</span><span class="o">.</span><span class="n">wakeup</span><span class="p">(</span><span class="n">_WAKEUP_NORMAL</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__garbage</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Wake the first task that actually wakes, mark the rest as</span>
                <span class="c"># junk.</span>
                <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">task</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">wakeup</span><span class="p">(</span><span class="n">_WAKEUP_NORMAL</span><span class="p">):</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__garbage</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span><span class="p">[:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__garbage</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># A cancelled wait becomes garbage on the waiting queue.  We keep</span>
        <span class="c"># count of how much garbage there is -- once the queue has more</span>
        <span class="c"># garbage than waiters it&#39;s probably time to rebuild the queue and</span>
        <span class="c"># keep only those waiters which haven&#39;t been woken yet.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__garbage</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__garbage</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span> <span class="o">=</span> <span class="p">[</span><span class="n">task</span>
                <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">task</span><span class="o">.</span><span class="n">woken</span><span class="p">()]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__garbage</span> <span class="o">=</span> <span class="mi">0</span>


<span class="k">class</span> <span class="nc">_Wakeup</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;A _Wakeup object is used when a task is to be suspended on one or more</span>
<span class="sd">    queues.  On wakeup the original task is woken, but only once: this is</span>
<span class="sd">    used to ensure that entries on other queues are effectively cancelled.&#39;&#39;&#39;</span>

    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s">&#39;__task&#39;</span><span class="p">,</span>           <span class="c"># Coroutine associated with task to wake</span>
        <span class="s">&#39;__wakeup_task&#39;</span><span class="p">,</span>    <span class="c"># Action to take on wakeup</span>
        <span class="s">&#39;__queue&#39;</span><span class="p">,</span>          <span class="c"># Queue where this wakeup object resides</span>
        <span class="s">&#39;__timers&#39;</span><span class="p">,</span>         <span class="c"># Timeout queue for this wakeup</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wakeup_task</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">timers</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__task</span> <span class="o">=</span> <span class="n">_coroutine</span><span class="o">.</span><span class="n">get_current</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__wakeup_task</span> <span class="o">=</span> <span class="n">wakeup_task</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__queue</span> <span class="o">=</span> <span class="n">queue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__timers</span> <span class="o">=</span> <span class="n">timers</span>

    <span class="k">def</span> <span class="nf">wakeup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reason</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__task</span><span class="p">:</span>
            <span class="c"># Let the scheduler know that this task has been woken, and forget</span>
            <span class="c"># about it, so we don&#39;t wake it again.</span>
            <span class="c">#    Note that it&#39;s rather important to mark this wakeup as woken</span>
            <span class="c"># *before* calling the queue cancel() functions, as otherwise</span>
            <span class="c"># their garbage collection will be confused!</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__wakeup_task</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__task</span><span class="p">,</span> <span class="n">reason</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__task</span> <span class="o">=</span> <span class="bp">None</span>

            <span class="c"># Each queue needs to be cancelled if it&#39;s not the wakeup reason.</span>
            <span class="c"># This test also properly deals with _WAKEUP_INTERRUPT, which</span>
            <span class="c"># requires both queues to be cancelled.</span>
            <span class="k">if</span> <span class="n">reason</span> <span class="o">!=</span> <span class="n">_WAKEUP_NORMAL</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__queue</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__queue</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">reason</span> <span class="o">!=</span> <span class="n">_WAKEUP_TIMEOUT</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__timers</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__timers</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>

            <span class="c"># Also drop our reference to the queue to avoid overextending</span>
            <span class="c"># object lifetime.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__queue</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">woken</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__task</span> <span class="ow">is</span> <span class="bp">None</span>


<span class="c"># Task wakeup reasons</span>
<span class="n">_WAKEUP_NORMAL</span> <span class="o">=</span> <span class="mi">0</span>     <span class="c"># Normal wakeup</span>
<span class="n">_WAKEUP_TIMEOUT</span> <span class="o">=</span> <span class="mi">1</span>    <span class="c"># Wakeup on timeout</span>
<span class="n">_WAKEUP_INTERRUPT</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c"># Special: transfer scheduler exception to main</span>


<span class="c"># Important system invariants:</span>
<span class="c">#   - A running task is not on any waiting queue.</span>
<span class="c">#       This is enforced by:</span>
<span class="c">#       1) when a task it suspended it is recorded on waiting queues by using</span>
<span class="c">#          a shared _Wakeup() object;</span>
<span class="c">#       2) the .wakeup() method is always used before resuming the task.</span>

<span class="k">class</span> <span class="nc">_Scheduler</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Coroutine activity scheduler.&#39;&#39;&#39;</span>

    <span class="c"># The scheduler runs in a dedicated stack.  It doesn&#39;t need much stack.</span>
    <span class="n">SCHEDULER_STACK_SIZE</span> <span class="o">=</span> <span class="mi">65536</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Creates the scheduler in its own coroutine and starts it running.</span>
<span class="sd">        We switch to the scheduler long enough for it to complete</span>
<span class="sd">        initialisation.&#39;&#39;&#39;</span>
        <span class="c"># We run the scheduler in its own coroutine to allow the main task to</span>
        <span class="c"># participate in scheduling.  This produces its own complications but</span>
        <span class="c"># makes for a more usable system.</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">_coroutine</span><span class="o">.</span><span class="n">get_current</span><span class="p">()</span>
        <span class="n">scheduler_task</span> <span class="o">=</span> <span class="n">_coroutine</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
            <span class="n">current</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">__scheduler</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">SCHEDULER_STACK_SIZE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_coroutine</span><span class="o">.</span><span class="n">switch</span><span class="p">(</span><span class="n">scheduler_task</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__scheduler</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">main_task</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;The top level scheduler loop.  Starts by creating the scheduler,</span>
<span class="sd">        and then manages dispatching from the top level.&#39;&#39;&#39;</span>

        <span class="c"># First create the scheduler and pass it back to our caller, who we</span>
        <span class="c"># expect to be the main task.  The next time we get control it&#39;s time</span>
        <span class="c"># to run the scheduling loop.</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="n">cls</span><span class="p">()</span>
        <span class="n">_coroutine</span><span class="o">.</span><span class="n">switch</span><span class="p">(</span><span class="n">main_task</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="c"># If the schedule loop raises an exception then propagate the</span>
        <span class="c"># exception up to the main thread before restarting the scheduler.</span>
        <span class="c"># This has mostly the right effects: a standalone program will</span>
        <span class="c"># terminate, and an interactive program will receive back control, and</span>
        <span class="c"># the scheduler should carry on operating.</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__schedule_loop</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c"># Switch to the main task asking it to re-raise the interrupt.</span>
                <span class="c"># First we have to make sure it&#39;s not on the run queue.</span>
                <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">reason</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__ready_queue</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">task</span> <span class="ow">is</span> <span class="n">main_task</span><span class="p">:</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ready_queue</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                        <span class="k">break</span>
                <span class="c"># All task wakeup entry points will interpret this as a</span>
                <span class="c"># request to re-raise the exception.</span>
                <span class="n">_coroutine</span><span class="o">.</span><span class="n">switch</span><span class="p">(</span><span class="n">main_task</span><span class="p">,</span> <span class="n">_WAKEUP_INTERRUPT</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># List of all tasks that are currently ready to be dispatched.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ready_queue</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># List of tasks waiting for ready_queue to become empty</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__yield_queue</span> <span class="o">=</span> <span class="n">_WakeupQueue</span><span class="p">()</span>
        <span class="c"># List of tasks waiting for a timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__timer_queue</span> <span class="o">=</span> <span class="n">_TimerQueue</span><span class="p">()</span>
        <span class="c"># Scheduler coroutine: this will be switched to whenever any other</span>
        <span class="c"># task decides to sleep.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__coroutine</span> <span class="o">=</span> <span class="n">_coroutine</span><span class="o">.</span><span class="n">get_current</span><span class="p">()</span>
        <span class="c"># Initially the schedule loop will run freely with its own select.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__poll_callback</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="c"># Dictionary of waitable descriptors for which polling needs to be</span>
        <span class="c"># done.  Each entry consists of an event mask together with a list of</span>
        <span class="c"># interested tasks.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__poll_queue</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c"># By default use blocking poll while waiting for the next event.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_poll_block</span> <span class="o">=</span> <span class="n">coselect</span><span class="o">.</span><span class="n">poll_block</span>


    <span class="k">def</span> <span class="nf">__tick</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;This must be called regularly to ensure that all waiting tasks are</span>
<span class="sd">        processed.  It processes all tasks that are ready to run and then runs</span>
<span class="sd">        all timers that have expired.&#39;&#39;&#39;</span>
        <span class="c"># Wake up all the expired timers on entry.  These go to the end of</span>
        <span class="c"># the ready queue.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__timer_queue</span><span class="o">.</span><span class="n">wake_expired</span><span class="p">()</span>
        <span class="c"># If the ready queue is still empty, now&#39;s the time to run the yield</span>
        <span class="c"># queue.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ready_queue</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__yield_queue</span><span class="o">.</span><span class="n">wake</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

        <span class="c"># Pick up the ready queue and process every task in it.  When each</span>
        <span class="c"># task is resumed it is passed a flag indicating whether it has been</span>
        <span class="c"># resumed because of an expired timer, or for some other reason</span>
        <span class="c"># (typically either a voluntary suspend, or a successful wait for an</span>
        <span class="c"># event).</span>
        <span class="n">ready_queue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ready_queue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ready_queue</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">task</span><span class="p">,</span> <span class="n">reason</span> <span class="ow">in</span> <span class="n">ready_queue</span><span class="p">:</span>
            <span class="n">_coroutine</span><span class="o">.</span><span class="n">switch</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">reason</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__schedule_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;This runs a scheduler loop without returning.&#39;&#39;&#39;</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="c"># Dispatch all waiting tasks</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__tick</span><span class="p">()</span>

            <span class="c"># Now see how long we have to wait for the next tick</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ready_queue</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">__yield_queue</span><span class="p">:</span>
                <span class="c"># There are ready tasks: don&#39;t wait</span>
                <span class="n">delay</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__timer_queue</span><span class="p">:</span>
                <span class="c"># There are timers waiting to fire: wait for the first one.  We</span>
                <span class="c"># don&#39;t sleep for less than 1ms: there&#39;s not a lot of point in a</span>
                <span class="c"># shorter timeout, and this works around some timer calculation</span>
                <span class="c"># quirks.</span>
                <span class="n">delay</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__timer_queue</span><span class="o">.</span><span class="n">timeout</span><span class="p">()</span> <span class="o">-</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">(),</span> <span class="mf">0.001</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Nothing to do: block until something external happens.</span>
                <span class="n">delay</span> <span class="o">=</span> <span class="bp">None</span>

            <span class="c"># Finally suspend until something is ready.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__wakeup_poll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__poll_suspend</span><span class="p">(</span><span class="n">delay</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__poll_suspend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delay</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Suspends the scheduler until the appropriate ready condition is</span>
<span class="sd">        reached.  Returns lists of ready file descriptors and events.&#39;&#39;&#39;</span>
        <span class="n">poll_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poll_queue</span> <span class="o">=</span> \
            <span class="n">coselect</span><span class="o">.</span><span class="n">_compute_poll_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__poll_queue</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poll_callback</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># If we&#39;re not being polled from outside, run our own poll.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_poll_block</span><span class="p">(</span><span class="n">poll_list</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># If the scheduler loop was invoked from outside then return</span>
            <span class="c"># control back to the caller: it will provide the select</span>
            <span class="c"># operation we need.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poll_callback</span><span class="o">.</span><span class="n">switch</span><span class="p">(</span><span class="n">poll_list</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">poll_scheduler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ready_list</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;This is called when the scheduler needs to be controlled from</span>
<span class="sd">        outside.  It will perform a full round of scheduling before returing</span>
<span class="sd">        control to the caller.</span>
<span class="sd">            Two values are returned, a list of descriptors and events plus</span>
<span class="sd">        a timeout, being precisely the values required for a call to</span>
<span class="sd">        poll_block().  A sensible default outer scheduler loop would be</span>

<span class="sd">            ready_list = []</span>
<span class="sd">            while True:</span>
<span class="sd">                ready_list = poll_block(*poll_scheduler(ready_list))</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poll_callback</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">,</span> <span class="s">&#39;Nested pollers will not work&#39;</span>

        <span class="c"># Switching to the scheduler will return control to us when the next</span>
        <span class="c"># round is complete.</span>
        <span class="c">#    Note that the first time this is called we may get an incomplete</span>
        <span class="c"># schedule, as we may be resuming inside the dispatch loop: in effect</span>
        <span class="c"># the first call to this routine interrupts the original scheduler.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__poll_callback</span> <span class="o">=</span> <span class="n">_coroutine</span><span class="o">.</span><span class="n">get_current</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_coroutine</span><span class="o">.</span><span class="n">switch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__coroutine</span><span class="p">,</span> <span class="n">ready_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__poll_callback</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="n">_WAKEUP_INTERRUPT</span><span class="p">:</span>
            <span class="c"># This case arises if we are main and the scheduler just died.</span>
            <span class="k">raise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>


    <span class="k">def</span> <span class="nf">spawn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">stack_size</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Spawns a new task: function is spawned as a new background task</span>
<span class="sd">        as a child of the scheduler task.&#39;&#39;&#39;</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">_coroutine</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__coroutine</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">stack_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ready_queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">task</span><span class="p">,</span> <span class="n">_WAKEUP_NORMAL</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">do_yield</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">until</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Hands control to the next task with work to do, will return as</span>
<span class="sd">        soon as there is time.&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wait_until</span><span class="p">(</span><span class="n">until</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__yield_queue</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">wait_until</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">until</span><span class="p">,</span> <span class="n">suspend_queue</span><span class="p">,</span> <span class="n">wakeup</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;The calling task is suspended.  If a deadline is given then the</span>
<span class="sd">        task will definitely be woken up when the deadline is reached if not</span>
<span class="sd">        before.  If a suspend_queue is given then the task is added to it</span>
<span class="sd">        (and it is the caller&#39;s responsibility to ensure the task is woken</span>
<span class="sd">        up, with a call to wakeup()).</span>
<span class="sd">            Returns True iff the wakeup is from a timeout.&#39;&#39;&#39;</span>
        <span class="c"># If no wakeup has been specified, create one.  This is a key</span>
        <span class="c"># component for ensuring consistent behaviour of the system: the</span>
        <span class="c"># wakeup object ensures each task is only woken up exactly once.</span>
        <span class="k">if</span> <span class="n">wakeup</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">wakeup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__Wakeup</span><span class="p">(</span><span class="n">suspend_queue</span><span class="p">,</span> <span class="n">until</span><span class="p">)</span>

        <span class="c"># If a timeout or a suspension queue has been specified, add</span>
        <span class="c"># ourselves as appropriate.  Failing either of these it&#39;s up to the</span>
        <span class="c"># caller to arrange a wakeup.</span>
        <span class="k">if</span> <span class="n">suspend_queue</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">suspend_queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wakeup</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">until</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__timer_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">wakeup</span><span class="p">,</span> <span class="n">until</span><span class="p">)</span>

        <span class="c"># Suspend until we&#39;re woken.</span>
        <span class="c"># Normally this call will return control to __tick(), but there are</span>
        <span class="c"># two other cases to consider.  On the very first suspend control is</span>
        <span class="c"># returned to the top of __scheduler(), and more interestingly, on</span>
        <span class="c"># suspending immediately after calling poll_scheduler() control is</span>
        <span class="c"># returned to __select().  This last case expects a list of ready</span>
        <span class="c"># descriptors to be returned, so we have to be compatible with this!</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_coroutine</span><span class="o">.</span><span class="n">switch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__coroutine</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="n">_WAKEUP_INTERRUPT</span><span class="p">:</span>
            <span class="c"># We get here if main is suspended and the scheduler decides</span>
            <span class="c"># to die.  Make sure our wakeup is cancelled, and then</span>
            <span class="c"># re-raise the offending exception.</span>
            <span class="n">wakeup</span><span class="o">.</span><span class="n">wakeup</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">raise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span> <span class="o">==</span> <span class="n">_WAKEUP_TIMEOUT</span>

    <span class="k">def</span> <span class="nf">poll_until</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">poller</span><span class="p">,</span> <span class="n">until</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Cooperative poll: the calling task is suspended until one of</span>
<span class="sd">        the specified waitable objects becomes ready or the timeout expires.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c"># Add our poller to the appropriate poll event queues so that we&#39;ll</span>
        <span class="c"># get woken.  Note that we don&#39;t need to worry about coming off the</span>
        <span class="c"># queue: this&#39;ll be managed in _compute_poll_list later on</span>
        <span class="n">poller</span><span class="o">.</span><span class="n">wakeup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__Wakeup</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">until</span><span class="p">)</span>
        <span class="k">for</span> <span class="nb">file</span> <span class="ow">in</span> <span class="n">poller</span><span class="o">.</span><span class="n">events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__poll_queue</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poller</span><span class="p">)</span>
        <span class="c"># It&#39;s vital to yield during this call, even if we have actually</span>
        <span class="c"># timed out -- otherwise the wakeup we&#39;ve just added to the poll</span>
        <span class="c"># queue will get processed when it&#39;s no longer valid (oops).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wait_until</span><span class="p">(</span><span class="n">until</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">poller</span><span class="o">.</span><span class="n">wakeup</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__Wakeup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">until</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">until</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_Wakeup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__wakeup_task</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_Wakeup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__wakeup_task</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__timer_queue</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__wakeup_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">reason</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">reason</span> <span class="o">!=</span> <span class="n">_WAKEUP_INTERRUPT</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ready_queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">task</span><span class="p">,</span> <span class="n">reason</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__wakeup_poll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">poll_result</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Called with the result of a system poll: a list of file descriptors</span>
<span class="sd">        and wakeup reasons.  Each waiting task is informed.&#39;&#39;&#39;</span>
        <span class="c"># Work through all the notified files: with each file is a received</span>
        <span class="c"># event mask which we&#39;ll pass through to the interested task.</span>
        <span class="c">#</span>
        <span class="c"># Some care is required here if we are to neither deliver spurious</span>
        <span class="c"># wakeups nor lose wakeups.</span>
        <span class="c">#     We make two assumption about our wakeup call, translating into</span>
        <span class="c"># assumptions on either coselect.poll_block or poll_scheduler:</span>
        <span class="c">#   1/ if an event is ready on a file we will eventually be notified;</span>
        <span class="c">#   2/ if an event is not ready we will not be notified -- in other</span>
        <span class="c">#      words, if a poll notify occurs we can safely access the file</span>
        <span class="c">#      without risk of blocking.</span>
        <span class="c">#</span>
        <span class="c"># The goal of the loop below is to translate these assumptions into</span>
        <span class="c"># corresponding properties on poll_until.  The problem arises when</span>
        <span class="c"># there is more than one listener on an event, as the first listener</span>
        <span class="c"># may consume the event before subsequent listeners receive it.</span>
        <span class="c">#     The simplest solution is to be to communicate each event to just</span>
        <span class="c"># one interested listener, but ensure that the event remains</span>
        <span class="c"># monitored.</span>
        <span class="k">for</span> <span class="nb">file</span><span class="p">,</span> <span class="n">events</span> <span class="ow">in</span> <span class="n">poll_result</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">poller</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poll_queue</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="c"># Consume any events taken by the woken process</span>
                <span class="n">events</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">poller</span><span class="o">.</span><span class="n">notify_wakeup</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="n">events</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Timedout</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Waiting for event timed out.&#39;&#39;&#39;</span>


<div class="viewcode-block" id="AbsTimeout"><a class="viewcode-back" href="../../cothread.html#cothread.AbsTimeout">[docs]</a><span class="k">def</span> <span class="nf">AbsTimeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;A timeout is represented in one of three forms:</span>

<span class="sd">    None            A timeout that never expires</span>
<span class="sd">    interval        A relative timeout interval</span>
<span class="sd">    (deadline,)     An absolute deadline</span>

<span class="sd">    This routine checks that the given input is in one of these three forms</span>
<span class="sd">    and returns a timeout in absolute deadline format.&#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">timeout</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">+</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">(),)</span>
</div>
<div class="viewcode-block" id="GetDeadline"><a class="viewcode-back" href="../../cothread.html#cothread.GetDeadline">[docs]</a><span class="k">def</span> <span class="nf">GetDeadline</span><span class="p">(</span><span class="n">timeout</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Returns the deadline associated with the given timeout, or None if there</span>
<span class="sd">    is no deadline.&#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">timeout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">timeout</span> <span class="o">+</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Deadline"><a class="viewcode-back" href="../../cothread.html#cothread.Deadline">[docs]</a><span class="k">def</span> <span class="nf">Deadline</span><span class="p">(</span><span class="n">deadline</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Converts a deadline into a timeout.&#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">deadline</span><span class="p">,)</span>

</div>
<span class="k">class</span> <span class="nc">EventBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;The base class for implementing events and signals.&#39;&#39;&#39;</span>

    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s">&#39;__wait_queue&#39;</span><span class="p">,</span>     <span class="c"># Queue of cothreads waiting to be woken</span>
        <span class="s">&#39;__wait_abort&#39;</span><span class="p">,</span>     <span class="c"># Count of abortable waits.</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># List of tasks currently waiting to be woken up.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__wait_queue</span> <span class="o">=</span> <span class="n">_WakeupQueue</span><span class="p">()</span>
        <span class="c"># Number of aborted waits that need to be emulated.  This is</span>
        <span class="c"># incremented by subclasses for each _Wakeup that needs to be</span>
        <span class="c"># simulated.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__wait_abort</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_WaitUntil</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Suspends the calling task until _Wakeup() is called.  Raises an</span>
<span class="sd">        exception if a timeout occurs first.&#39;&#39;&#39;</span>
        <span class="c"># If the event object is not ready we always yield control to ensure</span>
        <span class="c"># that other ready cothreads get the opportunity to run.</span>
        <span class="n">_validate_thread</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">_scheduler</span><span class="o">.</span><span class="n">wait_until</span><span class="p">(</span><span class="n">GetDeadline</span><span class="p">(</span><span class="n">timeout</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">__wait_queue</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Timedout</span><span class="p">(</span><span class="s">&#39;Timed out waiting for event&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_Wakeup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wake_all</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Wakes one or all waiting tasks.  Returns False if an aborted wait</span>
<span class="sd">        needs to be emulated.&#39;&#39;&#39;</span>
        <span class="n">_validate_thread</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__wait_abort</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wake_all</span><span class="p">:</span>
            <span class="c"># This is a special case: an aborted wait needs to be completed.</span>
            <span class="c"># This occurs when waiting needs to be simulated, in which case</span>
            <span class="c"># any resources consumed by the reader need to be consumed by the</span>
            <span class="c"># waker instead!</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__wait_abort</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__wait_abort</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__wait_queue</span><span class="o">.</span><span class="n">wake</span><span class="p">(</span><span class="n">wake_all</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">_AbortWait</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__wait_abort</span> <span class="o">+=</span> <span class="mi">1</span>


<div class="viewcode-block" id="Spawn"><a class="viewcode-back" href="../../cothread.html#cothread.Spawn">[docs]</a><span class="k">class</span> <span class="nc">Spawn</span><span class="p">(</span><span class="n">EventBase</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;This class is used to wrap cooperative threads: every task (except</span>
<span class="sd">    for main) managed by the scheduler should be an instance of this class.&#39;&#39;&#39;</span>

    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s">&#39;__function&#39;</span><span class="p">,</span>       <span class="c"># Function implementing cothread action</span>
        <span class="s">&#39;__args&#39;</span><span class="p">,</span>           <span class="c"># Positional arguments for action</span>
        <span class="s">&#39;__kargs&#39;</span><span class="p">,</span>          <span class="c"># Keyword arguments for action</span>
        <span class="s">&#39;__result&#39;</span><span class="p">,</span>         <span class="c"># Result when action has completed</span>
        <span class="s">&#39;__raise_on_wait&#39;</span><span class="p">,</span>  <span class="c"># Action to take on exception</span>
    <span class="p">]</span>

    <span class="c"># Set of all active processes for debugging</span>
    <span class="n">Cothreads</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;The given function and arguments will be called as a new task.</span>
<span class="sd">        All of the arguments will be be passed through to function, except for</span>
<span class="sd">        the special keyword raise_on_wait which defaults to False.</span>
<span class="sd">            If raise_on_wait is set then any exception raised during the</span>
<span class="sd">        execution of this task will be postponed until Wait() is called.  This</span>
<span class="sd">        allows such exceptions to be caught without disturbing the normal</span>
<span class="sd">        operation of the system.  Otherwise any exception is reported.&#39;&#39;&#39;</span>
        <span class="n">EventBase</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__function</span> <span class="o">=</span> <span class="n">function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__kargs</span> <span class="o">=</span> <span class="n">kargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__result</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__raise_on_wait</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;raise_on_wait&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="c"># Hand control over to the run method in the scheduler.</span>
        <span class="n">_validate_thread</span><span class="p">()</span>
        <span class="n">_scheduler</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__run</span><span class="p">,</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;stack_size&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c"># Try for normal successful result.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__result</span> <span class="o">=</span> <span class="p">(</span><span class="bp">True</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__function</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">__kargs</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c"># Oops: the task terminated with an exception.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__raise_on_wait</span><span class="p">:</span>
                <span class="c"># The creator of the task is willing to catch this exception,</span>
                <span class="c"># so hang onto it now until Wait() is called.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__result</span> <span class="o">=</span> <span class="p">(</span><span class="bp">False</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># No good.  We can&#39;t allow this exception to propagate, as</span>
                <span class="c"># doing so will kill the scheduler.  Instead report the</span>
                <span class="c"># traceback right here.</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&#39;Spawned task&#39;</span><span class="p">,</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__function</span><span class="p">,</span> <span class="s">&#39;__name__&#39;</span><span class="p">,</span> <span class="s">&#39;(unknown)&#39;</span><span class="p">),</span>
                    <span class="s">&#39;raised uncaught exception&#39;</span><span class="p">,</span> <span class="nb">file</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
                <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__result</span> <span class="o">=</span> <span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Wakeup</span><span class="p">(</span><span class="bp">False</span><span class="p">):</span>
            <span class="c"># Aborted wakeup: consume the result now, will cause a subsequent</span>
            <span class="c"># Wait() to fail, which it should.</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__result</span>
        <span class="c"># See wait_until() for an explanation of this return value.</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__nonzero__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Tests whether the event is signalled.&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__result</span><span class="p">)</span>

<div class="viewcode-block" id="Spawn.Wait"><a class="viewcode-back" href="../../cothread.html#cothread.Spawn.Wait">[docs]</a>    <span class="k">def</span> <span class="nf">Wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Waits until the task has completed.  May raise an exception if the</span>
<span class="sd">        task terminated with an exception and raise_on_wait was selected.</span>
<span class="sd">        Can only be called once, as the result is deleted after call.&#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__result</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_WaitUntil</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
        <span class="n">ok</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__result</span>
        <span class="k">if</span> <span class="n">ok</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c"># Re-raise the exception that actually killed the task here</span>
                <span class="c"># where it can be received by whoever waits on the task.</span>
                <span class="k">raise</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="c"># In this case result and self.__result contain a traceback.  To</span>
                <span class="c"># avoid circular references which will delay garbage collection,</span>
                <span class="c"># ensure these variables are deleted before the exception is</span>
                <span class="c"># caught.</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__result</span>
                <span class="k">del</span> <span class="n">result</span>
</div>
    <span class="k">def</span> <span class="nf">AbortWait</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Called instead of performing a proper wait to release any resources</span>
<span class="sd">        that might be consumed until the wait occurs.&#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__result</span><span class="p">:</span>
            <span class="c"># Result has already arrived.  Consume it silently now.</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Still need to wait: need to abort the next wakeup.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_AbortWait</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="Event"><a class="viewcode-back" href="../../cothread.html#cothread.Event">[docs]</a><span class="k">class</span> <span class="nc">Event</span><span class="p">(</span><span class="n">EventBase</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Any number of tasks can wait for an event to occur.  A single value</span>
<span class="sd">    can also be associated with the event.&#39;&#39;&#39;</span>

    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s">&#39;__value&#39;</span><span class="p">,</span>          <span class="c"># Value on this event</span>
        <span class="s">&#39;__auto_reset&#39;</span><span class="p">,</span>     <span class="c"># Whether value is consumed when taken</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">auto_reset</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;An event object is either signalled or reset.  Any task can wait</span>
<span class="sd">        for the object to become signalled, and it will be suspended until</span>
<span class="sd">        this occurs.</span>

<span class="sd">        The intial value can be specified, as can the behaviour on succesfully</span>
<span class="sd">        signalling a process: if auto_reset=True is specified then only one</span>
<span class="sd">        task at a time sees any individual signal on this object.&#39;&#39;&#39;</span>
        <span class="n">EventBase</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__value</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__auto_reset</span> <span class="o">=</span> <span class="n">auto_reset</span>

    <span class="k">def</span> <span class="nf">__nonzero__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Tests whether the event is signalled.&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__value</span><span class="p">)</span>

<div class="viewcode-block" id="Event.Wait"><a class="viewcode-back" href="../../cothread.html#cothread.Event.Wait">[docs]</a>    <span class="k">def</span> <span class="nf">Wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;The caller will block until the event becomes true, or until the</span>
<span class="sd">        timeout occurs if a timeout is specified.  A Timeout exception is</span>
<span class="sd">        raised if a timeout occurs.&#39;&#39;&#39;</span>
        <span class="c"># If one task resets the event while another is waiting the wait may</span>
        <span class="c"># fail, so we have to loop here.</span>
        <span class="n">deadline</span> <span class="o">=</span> <span class="n">AbsTimeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__value</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_WaitUntil</span><span class="p">(</span><span class="n">deadline</span><span class="p">)</span>

        <span class="n">ok</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__value</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__auto_reset</span><span class="p">:</span>
            <span class="c"># If this is an auto reset event then we reset it on exit;</span>
            <span class="c"># this means that we&#39;re the only thread that sees it being</span>
            <span class="c"># signalled.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__value</span> <span class="o">=</span> <span class="p">()</span>

        <span class="c"># Finally return the result as a value or raise an exception.</span>
        <span class="k">if</span> <span class="n">ok</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">result</span>
</div>
    <span class="k">def</span> <span class="nf">AbortWait</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Called instead of performing a proper wait to release any resources</span>
<span class="sd">        that might be consumed until the wait occurs.&#39;&#39;&#39;</span>
        <span class="c"># If this isn&#39;t an auto_reset event then our aborted wait makes no</span>
        <span class="c"># difference.  Otherwise we either consume the value now or on the</span>
        <span class="c"># next wakeup.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__auto_reset</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__value</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Reset</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_AbortWait</span><span class="p">()</span>

<div class="viewcode-block" id="Event.Signal"><a class="viewcode-back" href="../../cothread.html#cothread.Event.Signal">[docs]</a>    <span class="k">def</span> <span class="nf">Signal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Signals the event.  Any waiting tasks are scheduled to be woken.&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__value</span> <span class="o">=</span> <span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Wakeup</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__auto_reset</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Reset</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Event.SignalException"><a class="viewcode-back" href="../../cothread.html#cothread.Event.SignalException">[docs]</a>    <span class="k">def</span> <span class="nf">SignalException</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exception</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Signals the event with an exception: the next call to wait will</span>
<span class="sd">        receive an exception instead of a normal return value.&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__value</span> <span class="o">=</span> <span class="p">(</span><span class="bp">False</span><span class="p">,</span> <span class="n">exception</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Wakeup</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__auto_reset</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Reset</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Event.Reset"><a class="viewcode-back" href="../../cothread.html#cothread.Event.Reset">[docs]</a>    <span class="k">def</span> <span class="nf">Reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Resets the event (and erases the value).&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__value</span> <span class="o">=</span> <span class="p">()</span>

</div></div>
<div class="viewcode-block" id="EventQueue"><a class="viewcode-back" href="../../cothread.html#cothread.EventQueue">[docs]</a><span class="k">class</span> <span class="nc">EventQueue</span><span class="p">(</span><span class="n">EventBase</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;A queue of objects.  A queue can also be treated as an iterator.&#39;&#39;&#39;</span>

    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s">&#39;__queue&#39;</span><span class="p">,</span>          <span class="c"># Queue of values</span>
        <span class="s">&#39;__closed&#39;</span><span class="p">,</span>         <span class="c"># Used to halt iteration over this queue</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">EventBase</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__queue</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__closed</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns the number of objects waiting on the queue.&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__queue</span><span class="p">)</span>

<div class="viewcode-block" id="EventQueue.Wait"><a class="viewcode-back" href="../../cothread.html#cothread.EventQueue.Wait">[docs]</a>    <span class="k">def</span> <span class="nf">Wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns the next object from the queue, or raises a Timeout</span>
<span class="sd">        exception if the timeout expires first.&#39;&#39;&#39;</span>
        <span class="n">deadline</span> <span class="o">=</span> <span class="n">AbsTimeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__queue</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__closed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_WaitUntil</span><span class="p">(</span><span class="n">deadline</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__queue</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
</div>
    <span class="k">def</span> <span class="nf">AbortWait</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Called instead of performing a proper wait to release any resources</span>
<span class="sd">        that might be consumed until the wait occurs.&#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__queue</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__closed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_AbortWait</span><span class="p">()</span>

<div class="viewcode-block" id="EventQueue.Signal"><a class="viewcode-back" href="../../cothread.html#cothread.EventQueue.Signal">[docs]</a>    <span class="k">def</span> <span class="nf">Signal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Adds the given value to the tail of the queue.&#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__closed</span><span class="p">,</span> <span class="s">&#39;Can</span><span class="se">\&#39;</span><span class="s">t write to a closed queue&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Wakeup</span><span class="p">(</span><span class="bp">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="EventQueue.close"><a class="viewcode-back" href="../../cothread.html#cothread.EventQueue.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;An event queue can be closed.  This will cause waiting to raise</span>
<span class="sd">        the StopIteration exception (once existing entries have been read),</span>
<span class="sd">        and will prevent any further signals to the queue.&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__closed</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Wakeup</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;An event queue can itself be treated as an iterator: this allows</span>
<span class="sd">        event dispatching using a for loop, and provides some support for</span>
<span class="sd">        combining queues.&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="ThreadedEventQueue"><a class="viewcode-back" href="../../cothread.html#cothread.ThreadedEventQueue">[docs]</a><span class="k">class</span> <span class="nc">ThreadedEventQueue</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;An event queue designed to work with threads.&#39;&#39;&#39;</span>

    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s">&#39;__values&#39;</span><span class="p">,</span>         <span class="c"># List of queued values</span>
        <span class="s">&#39;__signal&#39;</span><span class="p">,</span>         <span class="c"># File handle used to notify new value</span>
        <span class="s">&#39;wait_descriptor&#39;</span><span class="p">,</span>  <span class="c"># File handle waited on for new values</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># According to the documentation this is thread safe, so we don&#39;t</span>
        <span class="c"># need to take any particular precautions when using this!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__values</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wait_descriptor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__signal</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">pipe</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns the number of objects waiting on the queue.&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Waits for a value to be written to the queue.  This can safely be</span>
<span class="sd">        called from either a cothread or another thread: the appropriate form</span>
<span class="sd">        of cooperative or normal blocking will be selected automatically.&#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">thread</span><span class="o">.</span><span class="n">get_ident</span><span class="p">()</span> <span class="o">==</span> <span class="n">_scheduler_thread_id</span><span class="p">:</span>
            <span class="c"># Normal cothread case, use cooperative wait</span>
            <span class="n">poll</span> <span class="o">=</span> <span class="n">coselect</span><span class="o">.</span><span class="n">poll_list</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Another thread, so block caller until ready</span>
            <span class="n">poll</span> <span class="o">=</span> <span class="n">coselect</span><span class="o">.</span><span class="n">poll_block</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">poll</span><span class="p">([(</span><span class="bp">self</span><span class="o">.</span><span class="n">wait_descriptor</span><span class="p">,</span> <span class="n">coselect</span><span class="o">.</span><span class="n">POLLIN</span><span class="p">)],</span> <span class="n">timeout</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Timedout</span><span class="p">(</span><span class="s">&#39;Timed out waiting for signal&#39;</span><span class="p">)</span>

        <span class="n">os</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wait_descriptor</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__values</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">Signal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Posts a value to the event queue.  This can safely be called from</span>
<span class="sd">        a thread or a cothread.&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__signal</span><span class="p">,</span> <span class="s">&#39;-&#39;</span><span class="p">)</span>



<span class="c"># Implements asynchronous (and &quot;lock free&quot;) synchronisation from any Python</span>
<span class="c"># thread to the main cothread thread.  Technically the Python Global Interpreter</span>
<span class="c"># Lock (GIL) plays an essential role in this code by serialising all the actions</span>
<span class="c"># here and ensuring that collections.deque actions are atomic (which follows</span>
<span class="c"># from its implementation as a C extension).</span>
<span class="c">#</span>
<span class="c"># Note that the signalling from Callback() to the callback_events() loop is</span>
<span class="c"># rather delicate.  Care is taken here to reduce the number of os.read/write</span>
<span class="c"># actions as these involve costly system calls, but without the hazard of losing</span>
<span class="c"># events which would result in deadlock.</span></div>
<span class="k">class</span> <span class="nc">_Callback</span><span class="p">:</span>
    <span class="n">COTHREAD_CALLBACK_STACK</span> <span class="o">=</span> \
        <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;COTHREAD_CALLBACK_STACK&#39;</span><span class="p">,</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wait</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">pipe</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waiting</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">Spawn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">callback_events</span><span class="p">,</span> <span class="n">stack_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">COTHREAD_CALLBACK_STACK</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">callback_events</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">waiting</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
                <span class="n">coselect</span><span class="o">.</span><span class="n">poll_list</span><span class="p">([(</span><span class="bp">self</span><span class="o">.</span><span class="n">wait</span><span class="p">,</span> <span class="n">coselect</span><span class="o">.</span><span class="n">POLLIN</span><span class="p">)])</span>
                <span class="n">os</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wait</span><span class="p">,</span> <span class="mi">4096</span><span class="p">)</span>    <span class="c"># Consume all pending wakeups</span>

            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
                <span class="n">action</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">action</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Asynchronous callback raised uncaught exception&#39;</span><span class="p">,</span>
                        <span class="nb">file</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
                    <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;This can be called from within any Python thread to arrange for</span>
<span class="sd">        action(*args) to be called in the context of the cothread thread.&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">action</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">waiting</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">waiting</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">os</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">signal</span><span class="p">,</span> <span class="s">&#39;-&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="Timer"><a class="viewcode-back" href="../../cothread.html#cothread.Timer">[docs]</a><span class="k">class</span> <span class="nc">Timer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;A cancellable one-shot or auto-retriggering timer.&#39;&#39;&#39;</span>

    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s">&#39;__timeout&#39;</span><span class="p">,</span>        <span class="c"># Time to wait until triggering timer</span>
        <span class="s">&#39;__callback&#39;</span><span class="p">,</span>       <span class="c"># Function to call when timer fires</span>
        <span class="s">&#39;__retrigger&#39;</span><span class="p">,</span>      <span class="c"># Enables retriggering timers</span>
        <span class="s">&#39;__reuse&#39;</span><span class="p">,</span>          <span class="c"># Set if timer can be reused</span>
        <span class="s">&#39;__control&#39;</span><span class="p">,</span>        <span class="c"># Event object for controlling timer</span>
        <span class="s">&#39;__fire&#39;</span><span class="p">,</span>           <span class="c"># Controls action when event timeout occurs</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span>
            <span class="n">retrigger</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">reuse</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">stack_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;The callback will be called (with no arguments) after the specified</span>
<span class="sd">        timeout.  If retrigger is set then the timer will automatically</span>
<span class="sd">        retrigger until it is cancelled.  Unless reuse or retrigger is set the</span>
<span class="sd">        timer will be cancelled once it fires and cannot be reused.&#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="nb">callable</span><span class="p">(</span><span class="n">callback</span><span class="p">),</span> <span class="s">&#39;Ensure the callback is callable&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__timeout</span> <span class="o">=</span> <span class="n">timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__callback</span> <span class="o">=</span> <span class="n">callback</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__retrigger</span> <span class="o">=</span> <span class="n">retrigger</span>        <span class="c"># Auto retrigger on each timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__reuse</span> <span class="o">=</span> <span class="n">reuse</span> <span class="ow">or</span> <span class="n">retrigger</span>   <span class="c"># Keep timer alive</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__control</span> <span class="o">=</span> <span class="n">Event</span><span class="p">()</span>            <span class="c"># Used to control main loop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__fire</span> <span class="o">=</span> <span class="bp">True</span>                  <span class="c"># False if control event pending</span>
        <span class="n">Spawn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__timer</span><span class="p">,</span> <span class="n">stack_size</span> <span class="o">=</span> <span class="n">stack_size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__timer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">running</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">while</span> <span class="n">running</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__control</span><span class="o">.</span><span class="n">Wait</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__timeout</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">Timedout</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fire</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__retrigger</span><span class="p">:</span>
                        <span class="c"># Unless we&#39;re automatically retriggering, any new</span>
                        <span class="c"># timeout has to be specified anew.</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__timeout</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__callback</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__fire</span> <span class="o">=</span> <span class="bp">True</span>      <span class="c"># We&#39;ve seen the control event</span>

            <span class="n">running</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__reuse</span>

        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__callback</span>     <span class="c"># Try to avoid reference loops</span>

<div class="viewcode-block" id="Timer.cancel"><a class="viewcode-back" href="../../cothread.html#cothread.Timer.cancel">[docs]</a>    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Cancels the timer: the timer is guaranteed not to fire once this</span>
<span class="sd">        call has been made.  A cancelled timer cannot be reset.&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__reuse</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__fire</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__control</span><span class="o">.</span><span class="n">Signal</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Timer.reset"><a class="viewcode-back" href="../../cothread.html#cothread.Timer.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">retrigger</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Resets the timer.  The timeout is reset to the given timeout and the</span>
<span class="sd">        timer is restarted.  A timeout of None can be used to temporarily</span>
<span class="sd">        suspend a timer.&#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__reuse</span><span class="p">,</span> <span class="s">&#39;Cannot reuse this timer&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__timeout</span> <span class="o">=</span> <span class="n">timeout</span>
        <span class="k">if</span> <span class="n">retrigger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__retrigger</span> <span class="o">=</span> <span class="n">retrigger</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__fire</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__control</span><span class="o">.</span><span class="n">Signal</span><span class="p">()</span>

</div></div>
<div class="viewcode-block" id="WaitForAll"><a class="viewcode-back" href="../../cothread.html#cothread.WaitForAll">[docs]</a><span class="k">def</span> <span class="nf">WaitForAll</span><span class="p">(</span><span class="n">event_list</span><span class="p">,</span> <span class="n">timeout</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Waits for all events in the event list to become ready or for the</span>
<span class="sd">    timeout to expire.&#39;&#39;&#39;</span>
    <span class="c"># Make sure that the timeout is actually a deadline, then it&#39;s easy to do</span>
    <span class="c"># all the waits in sequence.</span>
    <span class="n">timeout</span> <span class="o">=</span> <span class="n">AbsTimeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
    <span class="c"># Unfortunately our waiting can be interrupted by an exception.  To avoid</span>
    <span class="c"># leaking memory in this case we perform simulated waits on any remaining</span>
    <span class="c"># events.  This is a good deal more complicated than</span>
    <span class="c">#       return [event.Wait(timeout) for event in event_list]</span>
    <span class="c"># which is what it ought to be!</span>
    <span class="n">event_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">event_list</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>      <span class="c"># In case event_list is empty!</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">event</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">event_list</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">Wait</span><span class="p">(</span><span class="n">timeout</span><span class="p">))</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">event_list</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">event</span><span class="o">.</span><span class="n">AbortWait</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">result</span>



<span class="c"># Other possibly desirable entites:</span>
<span class="c">#</span>
<span class="c">#   The ability to wait for an event to occur on one of a set of objects.</span>
<span class="c">#       This would probably require quite deep hooking into the queueing</span>
<span class="c">#       mechanism, and seems of limited value (the natural alternative is to</span>
<span class="c">#       create a task per event).</span>
<span class="c">#</span>
<span class="c">#   The ability to kill a task</span>
<span class="c">#       This is probably doable with something equivalent to the .throw greenlet</span>
<span class="c">#       method (or even with a special wakeup value), but may require some care.</span>

</div>
<span class="n">_QuitEvent</span> <span class="o">=</span> <span class="n">Event</span><span class="p">(</span><span class="n">auto_reset</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>

<div class="viewcode-block" id="Quit"><a class="viewcode-back" href="../../cothread.html#cothread.Quit">[docs]</a><span class="k">def</span> <span class="nf">Quit</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;Signals the quit event.  Once signalled it stays signalled.&#39;&#39;&#39;</span>
    <span class="n">_QuitEvent</span><span class="o">.</span><span class="n">Signal</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="WaitForQuit"><a class="viewcode-back" href="../../cothread.html#cothread.WaitForQuit">[docs]</a><span class="k">def</span> <span class="nf">WaitForQuit</span><span class="p">(</span><span class="n">catch_interrupt</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Waits for the quit event to be signalled.  If catch_interrupt is True</span>
<span class="sd">    then control-C will only signal the quit event and will not generate an</span>
<span class="sd">    exception; this does mean that the only way to interrupt a misbehaving loop</span>
<span class="sd">    is to use another signal such as SIGQUIT (C-\)&#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">catch_interrupt</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">signal</span>
        <span class="k">def</span> <span class="nf">quit</span><span class="p">(</span><span class="n">signum</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
            <span class="n">_QuitEvent</span><span class="o">.</span><span class="n">Signal</span><span class="p">()</span>
        <span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">quit</span><span class="p">)</span>

    <span class="n">_QuitEvent</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>


<span class="c"># There is only the one scheduler, which we create right away.  A dedicated</span>
<span class="c"># scheduler task is created: this allows the main task to suspend, but does</span>
<span class="c"># mean that the scheduler is not the parent of all the tasks it&#39;s managing.</span></div>
<span class="n">_scheduler</span> <span class="o">=</span> <span class="n">_Scheduler</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
<span class="c"># We hang onto the thread ID for the cothread thread (at present there can</span>
<span class="c"># only be one) so that we can recognise when we&#39;re in another thread.</span>
<span class="n">_scheduler_thread_id</span> <span class="o">=</span> <span class="n">thread</span><span class="o">.</span><span class="n">get_ident</span><span class="p">()</span>


<span class="c"># Thread validation: ensure cothreads aren&#39;t used across threads!</span>
<span class="k">def</span> <span class="nf">_validate_thread</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">_scheduler_thread_id</span> <span class="o">==</span> <span class="n">thread</span><span class="o">.</span><span class="n">get_ident</span><span class="p">(),</span> \
        <span class="s">&#39;Cannot use cothread with multiple threads.  Consider using &#39;</span> \
        <span class="s">&#39;ThreadedEventQueue if necessary.&#39;</span>

<span class="c"># This is the asynchronous callback method.</span>
<span class="n">Callback</span> <span class="o">=</span> <span class="n">_Callback</span><span class="p">()</span>


<div class="viewcode-block" id="SleepUntil"><a class="viewcode-back" href="../../cothread.html#cothread.SleepUntil">[docs]</a><span class="k">def</span> <span class="nf">SleepUntil</span><span class="p">(</span><span class="n">deadline</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Sleep until the specified deadline.  Control will always be yielded,</span>
<span class="sd">    even if the timeout has already passed.&#39;&#39;&#39;</span>
    <span class="n">_validate_thread</span><span class="p">()</span>
    <span class="n">_scheduler</span><span class="o">.</span><span class="n">wait_until</span><span class="p">(</span><span class="n">deadline</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Sleep"><a class="viewcode-back" href="../../cothread.html#cothread.Sleep">[docs]</a><span class="k">def</span> <span class="nf">Sleep</span><span class="p">(</span><span class="n">timeout</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Sleep until the specified timeout has expired.&#39;&#39;&#39;</span>
    <span class="n">SleepUntil</span><span class="p">(</span><span class="n">GetDeadline</span><span class="p">(</span><span class="n">timeout</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Yield"><a class="viewcode-back" href="../../cothread.html#cothread.Yield">[docs]</a><span class="k">def</span> <span class="nf">Yield</span><span class="p">(</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Hands control back to the scheduler.  Control is returned either after</span>
<span class="sd">    the specified timeout has passed, or as soon as there are no active jobs</span>
<span class="sd">    waiting to be run.&#39;&#39;&#39;</span>
    <span class="n">_validate_thread</span><span class="p">()</span>
    <span class="n">_scheduler</span><span class="o">.</span><span class="n">do_yield</span><span class="p">(</span><span class="n">GetDeadline</span><span class="p">(</span><span class="n">timeout</span><span class="p">))</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">Cothread  documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Michael Abbott.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.
    </div>
  </body>
</html>