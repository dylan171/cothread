

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>1. Using the cothread Library &mdash; Cothread  documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Cothread  documentation" href="index.html" />
    <link rel="next" title="2. Using the catools Library" href="catools.html" />
    <link rel="prev" title="Welcome to Cothread’s documentation!" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="catools.html" title="2. Using the catools Library"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Welcome to Cothread’s documentation!"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Cothread  documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-cothread">
<span id="using-the-cothread-library"></span><span id="cothread"></span><h1>1. Using the cothread Library<a class="headerlink" href="#module-cothread" title="Permalink to this headline">¶</a></h1>
<p>The <a class="reference internal" href="#module-cothread" title="cothread"><tt class="xref py py-mod docutils literal"><span class="pre">cothread</span></tt></a> Python library is designed for building tools using
cooperative threading.  This means that, with care, programs can effectively
run several tasks simultaneously.</p>
<p>The <a class="reference internal" href="catools.html#module-cothread.catools" title="cothread.catools"><tt class="xref py py-mod docutils literal"><span class="pre">cothread.catools</span></tt></a> library is designed to support easy channel access
from Python, and makes essential use of the features of cooperative threads &#8211;
in particular, <a class="reference internal" href="catools.html#cothread.catools.camonitor" title="cothread.catools.camonitor"><tt class="xref py py-func docutils literal"><span class="pre">catools.camonitor()</span></tt></a> notifies updates in the background.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="catools.html#catools"><em>Using the catools Library</em></a>.</p>
</div>
<div class="section" id="introduction-to-cothreads">
<h2>1.1. Introduction to Cothreads<a class="headerlink" href="#introduction-to-cothreads" title="Permalink to this headline">¶</a></h2>
<p>Cothreads (or &#8220;cooperative threads&#8221;) are an approach to concurrent programming
where there is only one true thread of processing, but apparently concurrent
processes (or <em>cothreads</em>) can cooperatively share the processor.  Control is
passed from one cothread to another when the current cothread explicitly
suspends control, ultimately via a call to a <a class="reference internal" href="#module-cothread" title="cothread"><tt class="xref py py-mod docutils literal"><span class="pre">cothread</span></tt></a> library routine.
This means that between such suspending calls control will not be interrupted.
This has two advantages:</p>
<ul class="simple">
<li>No locking between threads is required.  This is a very helpful benefit of
using cothreads, as getting locking between multiple threads right can be
suprisingly difficult.</li>
<li>The thread of processing is frequently more predictable: between two
suspension points there is no possibility of unexpected background activity!</li>
</ul>
<p>On the other hand, there is one disadvantage which needs to be kept in mind:</p>
<ul class="simple">
<li>If a cothread blocks (for example, by calling <tt class="xref py py-func docutils literal"><span class="pre">time.sleep()</span></tt> or reading
from a blocking socket or remote file without first calling a select function)
then <em>all</em> cothreads will be blocked.  The cothread library provides routines
to help with this (see <a class="reference internal" href="#cothread.Sleep" title="cothread.Sleep"><tt class="xref py py-func docutils literal"><span class="pre">Sleep()</span></tt></a>, <a class="reference internal" href="#cothread.select" title="cothread.select"><tt class="xref py py-func docutils literal"><span class="pre">select()</span></tt></a> and <a class="reference internal" href="#cothread.socket" title="cothread.socket"><tt class="xref py py-class docutils literal"><span class="pre">socket</span></tt></a>
below).</li>
</ul>
<p>To use the <a class="reference internal" href="#module-cothread" title="cothread"><tt class="xref py py-mod docutils literal"><span class="pre">cothread</span></tt></a> library the following overall structure should be
followed in the top level application:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># First the version of cothread library must be specified</span>
<span class="kn">from</span> <span class="nn">pkg_resources</span> <span class="kn">import</span> <span class="n">require</span>
<span class="n">require</span><span class="p">(</span><span class="s">&#39;cothread==2.1&#39;</span><span class="p">)</span>    <span class="c"># or just require(&#39;cothread&#39;)</span>

<span class="c"># Import the cothread library in each module that uses it.</span>
<span class="kn">import</span> <span class="nn">cothread</span>

<span class="c"># Enable Qt processing, hang onto application instance if needed.</span>
<span class="n">qtapp</span> <span class="o">=</span> <span class="n">cothread</span><span class="o">.</span><span class="n">iqt</span><span class="p">()</span>      <span class="c"># Not needed if not using Qt</span>

<span class="c"># Do the real work of the module, including spawning any background tasks.</span>
<span class="o">...</span>

<span class="c"># Finally allow all background tasks to run to completion.</span>
<span class="n">cothread</span><span class="o">.</span><span class="n">WaitForQuit</span><span class="p">()</span>      <span class="c"># Or some other blocking construct</span>
</pre></div>
</div>
<ol class="arabic">
<li><p class="first"><tt class="docutils literal"><span class="pre">require('cothread==2.1')</span></tt>.  This statement is required by the way
Diamond Controls modules are managed: it is necessary to specify precisely
<em>which</em> version of a module is to be used.  This means that API changes
can be made in future releases without breaking existing code.</p>
<p>Alternatively <tt class="docutils literal"><span class="pre">require('cothread')</span></tt> can be used to request the most
recent installed version.</p>
<p>Note that the <tt class="xref py py-func docutils literal"><span class="pre">require()</span></tt> statements should only occur once in each
application: it is an easy mistake to place them at the head of each
Python module.</p>
</li>
<li><p class="first">If Qt is to be used (for any graphical user interface) then the cothread
library needs to be informed: this is done by calling <a class="reference internal" href="#cothread.iqt" title="cothread.iqt"><tt class="xref py py-func docutils literal"><span class="pre">iqt()</span></tt></a> before
any work is done with Qt.  This call ensures that Qt processing will occur
while the cothread scheduler is idle, and effectively turns Qt into
another cothread.  The Qt application instance is created by this call and
returned.</p>
</li>
<li><p class="first">Finally the main cothread (the thread of control used to start and run the
program) must not exit until the program has finished.  If all the desired
activity is in background tasks (spawned cothreads,
<a class="reference internal" href="catools.html#cothread.catools.camonitor" title="cothread.catools.camonitor"><tt class="xref py py-func docutils literal"><span class="pre">catools.camonitor()</span></tt></a> processing or other background activity) then the
simplest thing is to call <a class="reference internal" href="#cothread.WaitForQuit" title="cothread.WaitForQuit"><tt class="xref py py-func docutils literal"><span class="pre">WaitForQuit()</span></tt></a> before exiting: this will
wait until the <a class="reference internal" href="#cothread.Quit" title="cothread.Quit"><tt class="xref py py-func docutils literal"><span class="pre">Quit()</span></tt></a> function is called, or control-C is pressed
somewhere, or the last Qt window is closed.</p>
</li>
</ol>
<div class="section" id="cothread-suspension-points">
<h3>1.1.1. Cothread Suspension Points<a class="headerlink" href="#cothread-suspension-points" title="Permalink to this headline">¶</a></h3>
<p>When using cothreads only certain function calls will cause control to be
yielded to another cothread, or in other words, will cause suspension of the
calling cothread &#8211; here we call such a routine a &#8220;suspension point&#8221;.</p>
<p>Understanding suspension points is important for effective use of cothreads:
between suspension points no other cothread will run, and the current cothread
has exclusive control of the process (except for any &#8220;real&#8221; threads that
might be running).  Once a suspension point is reached any other cothread can
run, in fact typically <em>all</em> other ready cothreads will run to their own
suspension points before control is returned to the suspending cothread.</p>
<p>The following are suspension points in the core <a class="reference internal" href="#module-cothread" title="cothread"><tt class="xref py py-mod docutils literal"><span class="pre">cothread</span></tt></a> library:</p>
<dl class="docutils">
<dt><a class="reference internal" href="#cothread.Sleep" title="cothread.Sleep"><tt class="xref py py-func docutils literal"><span class="pre">Sleep()</span></tt></a>, <a class="reference internal" href="#cothread.SleepUntil" title="cothread.SleepUntil"><tt class="xref py py-func docutils literal"><span class="pre">SleepUntil()</span></tt></a></dt>
<dd>The caller is always suspended, even if the expiry time has passed, so
<tt class="docutils literal"><span class="pre">Sleep(0)</span></tt> has much the same effect as <tt class="docutils literal"><span class="pre">Yield()</span></tt>.</dd>
<dt><a class="reference internal" href="#cothread.Yield" title="cothread.Yield"><tt class="xref py py-func docutils literal"><span class="pre">Yield()</span></tt></a></dt>
<dd>This suspends the caller until all other active cothreads have run to
their own suspension points.</dd>
<dt><cite>event</cite>.<tt class="xref py py-meth docutils literal"><span class="pre">Wait()</span></tt></dt>
<dd><p class="first">On a <a class="reference internal" href="#cothread.Spawn" title="cothread.Spawn"><tt class="xref py py-class docutils literal"><span class="pre">Spawn</span></tt></a>, <a class="reference internal" href="#cothread.Event" title="cothread.Event"><tt class="xref py py-class docutils literal"><span class="pre">Event</span></tt></a> or <a class="reference internal" href="#cothread.EventQueue" title="cothread.EventQueue"><tt class="xref py py-class docutils literal"><span class="pre">EventQueue</span></tt></a> object the
<tt class="xref py py-meth docutils literal"><span class="pre">Wait()</span></tt> method will suspend the caller when the event object is not yet
ready, independently of whether the timeout has already expired.  To
determine whether an event object is ready without risking suspension call
<tt class="docutils literal"><span class="pre">bool()</span></tt> on the object.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is an incompatible change from cothread version 2.0 and earlier.
In earlier versions of cothread suspension does not occur on an expired
timeout, but unfortunately this can easily lead to starvation of other
cothreads.</p>
</div>
</dd>
</dl>
<p>The <tt class="xref py py-mod docutils literal"><span class="pre">cothread.coselect</span></tt> module adds the following suspension points:</p>
<dl class="docutils">
<dt><a class="reference internal" href="#cothread.select" title="cothread.select"><tt class="xref py py-func docutils literal"><span class="pre">select()</span></tt></a>, <a class="reference internal" href="#cothread.poll" title="cothread.poll"><tt class="xref py py-class docutils literal"><span class="pre">poll</span></tt></a>, <a class="reference internal" href="#cothread.poll_list" title="cothread.poll_list"><tt class="xref py py-func docutils literal"><span class="pre">poll_list()</span></tt></a></dt>
<dd>These are all always suspension points.</dd>
</dl>
<p>In the <a class="reference internal" href="catools.html#module-cothread.catools" title="cothread.catools"><tt class="xref py py-mod docutils literal"><span class="pre">cothread.catools</span></tt></a> module the following routines can cause
suspension (note that <a class="reference internal" href="catools.html#cothread.catools.camonitor" title="cothread.catools.camonitor"><tt class="xref py py-func docutils literal"><span class="pre">catools.camonitor()</span></tt></a> is the only routine guaranteed
not to suspend):</p>
<dl class="docutils">
<dt><a class="reference internal" href="catools.html#cothread.catools.caget" title="cothread.catools.caget"><tt class="xref py py-func docutils literal"><span class="pre">catools.caget()</span></tt></a></dt>
<dd>This is always a suspension point.</dd>
<dt><a class="reference internal" href="catools.html#cothread.catools.caput" title="cothread.catools.caput"><tt class="xref py py-func docutils literal"><span class="pre">catools.caput()</span></tt></a></dt>
<dd>This routine will normally cause the caller to suspend.  To avoid
suspension, only put to one PV, use <tt class="docutils literal"><span class="pre">wait=False</span></tt>, and ensure that the
channel is already connected &#8211; this will be the case if it has already
been successfully used in any <tt class="xref py py-mod docutils literal"><span class="pre">catools</span></tt> method.</dd>
</dl>
<p>The <tt class="xref py py-mod docutils literal"><span class="pre">cothread.cosocket</span></tt> module makes most socket operations into suspension
points when the corresponding socket operation is not yet ready.</p>
</div>
<div class="section" id="order-of-execution">
<h3>1.1.2. Order of Execution<a class="headerlink" href="#order-of-execution" title="Permalink to this headline">¶</a></h3>
<p>It is possible to be fairly precise about the order in which certain processes
will occur.</p>
<ul class="simple">
<li>Cothreads started by <a class="reference internal" href="#cothread.Spawn" title="cothread.Spawn"><tt class="xref py py-class docutils literal"><span class="pre">Spawn</span></tt></a> will initially be processed in the order
in which they were created with no other cothreads intervening.</li>
<li>Cothreads waiting on an event will be woken strictly in the sequence in
which waiting takes place, just so long as no timeout occurs.  Cothreads
woken by timeouts generally execute after other processing is complete.</li>
</ul>
<p>This ordering of processing together with the fact that cothreads are only
suspended when control needs to be lost means that certain guarantees about
ordering of processing can be made, in particular see <a class="reference internal" href="catools.html#cothread.catools.caput" title="cothread.catools.caput"><tt class="xref py py-func docutils literal"><span class="pre">catools.caput()</span></tt></a>.</p>
</div>
<div class="section" id="callbacks-and-timers">
<h3>1.1.3. Callbacks and Timers<a class="headerlink" href="#callbacks-and-timers" title="Permalink to this headline">¶</a></h3>
<p>Callbacks and timers are also provided through the cothread library, and it is
important to understand how they interact with other routines.</p>
<dl class="docutils">
<dt>Timers</dt>
<dd><p class="first">Timers are created by the <a class="reference internal" href="#cothread.Timer" title="cothread.Timer"><tt class="xref py py-class docutils literal"><span class="pre">Timer</span></tt></a> function documented below.  The
callback that is invoked as part of the timer is a fresh cothread, spawned
when the timer is created.  This means that the timer callback function can
run for as long as desired without interfering with other timer callbacks
(so long as it suspends regularly, of course!)</p>
<p class="last">Note however that a timer will not retrigger itself until its current
callback routine completes.</p>
</dd>
<dt>Callbacks from <a class="reference internal" href="catools.html#cothread.catools.camonitor" title="cothread.catools.camonitor"><tt class="xref py py-func docutils literal"><span class="pre">catools.camonitor()</span></tt></a></dt>
<dd>The callback routines called in response to <a class="reference internal" href="catools.html#cothread.catools.camonitor" title="cothread.catools.camonitor"><tt class="xref py py-func docutils literal"><span class="pre">catools.camonitor()</span></tt></a> are
all invoked on a single cothread.  This means that extended processing
within a single callback will prevent any other callbacks from being
processed.  To avoid this either spawn a new cothread to perform further
process, or communicate with an existing separate cothread.</dd>
<dt>Other callbacks</dt>
<dd>Other callbacks will depend on the library generating them, but it is safest
to treat them as &#8220;blocking&#8221; in the sense described above.</dd>
</dl>
</div>
<div class="section" id="timeouts-and-deadlines">
<h3>1.1.4. Timeouts and Deadlines<a class="headerlink" href="#timeouts-and-deadlines" title="Permalink to this headline">¶</a></h3>
<p>All of the waiting methods in the <a class="reference internal" href="#module-cothread" title="cothread"><tt class="xref py py-mod docutils literal"><span class="pre">cothread</span></tt></a> library take a <cite>timeout</cite>
argument.  This can be in one of three forms:</p>
<dl class="docutils">
<dt><tt class="xref py py-const docutils literal"><span class="pre">None</span></tt></dt>
<dd>A timeout of <tt class="xref py py-const docutils literal"><span class="pre">None</span></tt> means that the timeout will never complete, so
for example a call to <tt class="docutils literal"><span class="pre">Sleep(None)</span></tt> will never return, and so is not
useful, but this option is useful in other cases when no timeout is wanted.</dd>
<dt>Timeout interval in seconds</dt>
<dd>A numerical argument is interpreted as a timeout interval in seconds from
the time of call.  Note that although a timeout of 0 will immediately
timeout, cothread suspension will still occur.</dd>
<dt><tt class="docutils literal"><span class="pre">(</span></tt> deadline in seconds <tt class="docutils literal"><span class="pre">,)</span></tt></dt>
<dd>A tuple containing one numerical value is interpreted as a timeout deadline
in seconds in the <tt class="docutils literal"><span class="pre">time.time()</span></tt> epoch.  If the deadline has already passed
the call will timeout, but cothread suspension will occur first.</dd>
</dl>
<p>The following helper functions are available for working with timeouts:</p>
<dl class="function">
<dt id="cothread.AbsTimeout">
<tt class="descclassname">cothread.</tt><tt class="descname">AbsTimeout</tt><big>(</big><em>timeout</em><big>)</big><a class="reference internal" href="_modules/cothread/cothread.html#AbsTimeout"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.AbsTimeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a timeout and returns a timeout, ensuring that <cite>timeout</cite> is in
deadline format (or <tt class="xref py py-const docutils literal"><span class="pre">None</span></tt>).  If repeated wait functions are to be
called with the same desired timeout this should be used to ensure the
timeout is a deadline.</p>
</dd></dl>

<dl class="function">
<dt id="cothread.Deadline">
<tt class="descclassname">cothread.</tt><tt class="descname">Deadline</tt><big>(</big><em>deadline</em><big>)</big><a class="reference internal" href="_modules/cothread/cothread.html#Deadline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.Deadline" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a deadline in <tt class="docutils literal"><span class="pre">time.time()</span></tt> epoch seconds into a <a class="reference internal" href="#module-cothread" title="cothread"><tt class="xref py py-mod docutils literal"><span class="pre">cothread</span></tt></a>
timeout format.</p>
</dd></dl>

<dl class="function">
<dt id="cothread.GetDeadline">
<tt class="descclassname">cothread.</tt><tt class="descname">GetDeadline</tt><big>(</big><em>timeout</em><big>)</big><a class="reference internal" href="_modules/cothread/cothread.html#GetDeadline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.GetDeadline" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the associated deadline in seconds, or returns <tt class="xref py py-const docutils literal"><span class="pre">None</span></tt> if
<cite>timeout</cite> is <tt class="xref py py-const docutils literal"><span class="pre">None</span></tt>.</p>
</dd></dl>

</div>
</div>
<div class="section" id="cothread-api">
<h2>1.2. Cothread API<a class="headerlink" href="#cothread-api" title="Permalink to this headline">¶</a></h2>
<p>The following functions define the basic cothread interface provided by this
module.</p>
<dl class="class">
<dt id="cothread.Spawn">
<em class="property">class </em><tt class="descclassname">cothread.</tt><tt class="descname">Spawn</tt><big>(</big><em>function</em>, <em>arguments</em>, <em>raise_on_wait=False</em>, <em>stack_size=0</em>, <em>...</em><big>)</big><a class="reference internal" href="_modules/cothread/cothread.html#Spawn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.Spawn" title="Permalink to this definition">¶</a></dt>
<dd><p>A new cooperative thread, or <em>cothread</em>, is created as a call to
<tt class="docutils literal"><span class="pre">function(arguments)</span></tt> where <cite>arguments</cite> can be any list of values and
keyword arguments (except for the <cite>raise_on_wait</cite> and <cite>stack_size</cite>
arguments).  This routine is not a suspension point.</p>
<p>This is the fundamental building block of the cothreading library.  It is
quite cheap to spawn fresh cothreads, and so this constructor can be used
freely.</p>
<p>The following arguments are treated specially by this routine:</p>
<dl class="docutils">
<dt><cite>raise_on_wait</cite></dt>
<dd>By default any exception raised by running <tt class="docutils literal"><span class="pre">function(arguments)</span></tt> is
caught and reported by a traceback to <tt class="xref py py-const docutils literal"><span class="pre">stderr</span></tt>.  If this flag is
set then instead the exception is retained and returned when
<a class="reference internal" href="#cothread.Spawn.Wait" title="cothread.Spawn.Wait"><tt class="xref py py-meth docutils literal"><span class="pre">Wait()</span></tt></a> is called.</dd>
<dt><cite>stack_size</cite></dt>
<dd>If a non-zero <cite>stack_size</cite> is specified the new cothread is allocated
its own stack, otherwise it will share the main process stack.  The
tradeoffs involved in whether to allocate a stack are subtle.  By
default it is safest to leave this parameter unset.</dd>
</dl>
<p>It is possible to wait for the completion of a spawned cothread by calling
its <a class="reference internal" href="#cothread.Spawn.Wait" title="cothread.Spawn.Wait"><tt class="xref py py-meth docutils literal"><span class="pre">Wait()</span></tt></a> method:</p>
<dl class="method">
<dt id="cothread.Spawn.Wait">
<tt class="descname">Wait</tt><big>(</big><em>timeout=None</em><big>)</big><a class="reference internal" href="_modules/cothread/cothread.html#Spawn.Wait"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.Spawn.Wait" title="Permalink to this definition">¶</a></dt>
<dd><p>This blocks until the spawned cothread completes, either by returning
from its function call, or by raising an exception.  Note that only one
waiter will be woken.  If the cothread was created with <cite>raise_on_wait</cite>
set to <tt class="xref py py-const docutils literal"><span class="pre">True</span></tt> then any exception raised by the cothread will be
re-raised when <a class="reference internal" href="#cothread.Spawn.Wait" title="cothread.Spawn.Wait"><tt class="xref py py-meth docutils literal"><span class="pre">Wait()</span></tt></a> is called.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="cothread.Sleep">
<tt class="descclassname">cothread.</tt><tt class="descname">Sleep</tt><big>(</big><em>timeout</em><big>)</big><a class="reference internal" href="_modules/cothread/cothread.html#Sleep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.Sleep" title="Permalink to this definition">¶</a></dt>
<dt id="cothread.SleepUntil">
<tt class="descclassname">cothread.</tt><tt class="descname">SleepUntil</tt><big>(</big><em>time</em><big>)</big><a class="reference internal" href="_modules/cothread/cothread.html#SleepUntil"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.SleepUntil" title="Permalink to this definition">¶</a></dt>
<dd><p>The calling task is suspended until the given time.  <a class="reference internal" href="#cothread.Sleep" title="cothread.Sleep"><tt class="xref py py-func docutils literal"><span class="pre">Sleep()</span></tt></a> suspends
the task for at least delay seconds, <a class="reference internal" href="#cothread.SleepUntil" title="cothread.SleepUntil"><tt class="xref py py-func docutils literal"><span class="pre">SleepUntil()</span></tt></a> suspends until the
specified time has passed (<cite>time</cite> is defined as the value returned by
<tt class="docutils literal"><span class="pre">time.time()</span></tt>).</p>
</dd></dl>

<dl class="function">
<dt id="cothread.Yield">
<tt class="descclassname">cothread.</tt><tt class="descname">Yield</tt><big>(</big><em>timeout=0</em><big>)</big><a class="reference internal" href="_modules/cothread/cothread.html#Yield"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.Yield" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#cothread.Yield" title="cothread.Yield"><tt class="xref py py-func docutils literal"><span class="pre">Yield()</span></tt></a> suspends control so that all other potentially busy tasks
can run.  Control is not returned to the calling task until all other
active tasks have been processed, or the timeout has expired.</p>
</dd></dl>

<p>Communication between cothreads is provided by <a class="reference internal" href="#cothread.Event" title="cothread.Event"><tt class="xref py py-class docutils literal"><span class="pre">Event</span></tt></a> and
<a class="reference internal" href="#cothread.EventQueue" title="cothread.EventQueue"><tt class="xref py py-class docutils literal"><span class="pre">EventQueue</span></tt></a> objects.  An <a class="reference internal" href="#cothread.Event" title="cothread.Event"><tt class="xref py py-class docutils literal"><span class="pre">Event</span></tt></a> can hold at most one value (or
signal), while an <a class="reference internal" href="#cothread.EventQueue" title="cothread.EventQueue"><tt class="xref py py-class docutils literal"><span class="pre">EventQueue</span></tt></a> can hold a list of unbounded length.</p>
<dl class="class">
<dt id="cothread.Event">
<em class="property">class </em><tt class="descclassname">cothread.</tt><tt class="descname">Event</tt><big>(</big><em>auto_reset=True</em><big>)</big><a class="reference internal" href="_modules/cothread/cothread.html#Event"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.Event" title="Permalink to this definition">¶</a></dt>
<dd><p>Event objects are initially created unsignalled.  The <cite>auto_reset</cite> flag
determines whether the signalled state of the event object is persistent,
and determines how many cothreads are woken when <a class="reference internal" href="#cothread.Event.Signal" title="cothread.Event.Signal"><tt class="xref py py-meth docutils literal"><span class="pre">Signal()</span></tt></a> is called
on an event.  The <tt class="xref py py-class docutils literal"><span class="pre">bool</span></tt> state of an event object is <tt class="xref py py-const docutils literal"><span class="pre">True</span></tt>
iff it is signalled.</p>
<p>The following methods define the behaviour of this object.</p>
<dl class="method">
<dt id="cothread.Event.Wait">
<tt class="descname">Wait</tt><big>(</big><em>timeout=None</em><big>)</big><a class="reference internal" href="_modules/cothread/cothread.html#Event.Wait"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.Event.Wait" title="Permalink to this definition">¶</a></dt>
<dd><p>The calling cothread will be suspended until a signal is written to the
<a class="reference internal" href="#cothread.Event" title="cothread.Event"><tt class="xref py py-class docutils literal"><span class="pre">Event</span></tt></a> by a call to <a class="reference internal" href="#cothread.Event.Signal" title="cothread.Event.Signal"><tt class="xref py py-meth docutils literal"><span class="pre">Signal()</span></tt></a>, at which point the value
passed to <a class="reference internal" href="#cothread.Event.Signal" title="cothread.Event.Signal"><tt class="xref py py-meth docutils literal"><span class="pre">Signal()</span></tt></a> is returned.  If a timeout occurs (a timeout
of <tt class="xref py py-const docutils literal"><span class="pre">None</span></tt> specifies no timeout) this is signalled by raising the
exception <tt class="xref py py-exc docutils literal"><span class="pre">Timedout</span></tt>.</p>
</dd></dl>

<p>If <cite>auto_reset</cite> was specified as <tt class="xref py py-const docutils literal"><span class="pre">True</span></tt> then the signal is consumed,
and subsequent calls to <a class="reference internal" href="#cothread.Event.Wait" title="cothread.Event.Wait"><tt class="xref py py-meth docutils literal"><span class="pre">Wait()</span></tt></a> will block until further <a class="reference internal" href="#cothread.Event.Signal" title="cothread.Event.Signal"><tt class="xref py py-meth docutils literal"><span class="pre">Signal()</span></tt></a>
calls occur.</p>
<dl class="method">
<dt id="cothread.Event.Signal">
<tt class="descname">Signal</tt><big>(</big><em>value=None</em><big>)</big><a class="reference internal" href="_modules/cothread/cothread.html#Event.Signal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.Event.Signal" title="Permalink to this definition">¶</a></dt>
<dd><p>The event object is marked as signalled and the value passed is recorded
to be returned by a call to <a class="reference internal" href="#cothread.Event.Wait" title="cothread.Event.Wait"><tt class="xref py py-meth docutils literal"><span class="pre">Wait()</span></tt></a>.  If one or more cothreads are
waiting for a signal then at least one will be woken with the new value
(if <cite>auto_reset</cite> is <tt class="xref py py-const docutils literal"><span class="pre">True</span></tt> then only one will be woken, otherwise
all will be).</p>
<p>Note that this routine does <em>not</em> suspend the caller, even if another
cothread is woken: it will not process until later.</p>
</dd></dl>

<dl class="method">
<dt id="cothread.Event.SignalException">
<tt class="descname">SignalException</tt><big>(</big><em>exception</em><big>)</big><a class="reference internal" href="_modules/cothread/cothread.html#Event.SignalException"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.Event.SignalException" title="Permalink to this definition">¶</a></dt>
<dd><p>This is similar in effect to <a class="reference internal" href="#cothread.Event.Signal" title="cothread.Event.Signal"><tt class="xref py py-meth docutils literal"><span class="pre">Signal()</span></tt></a>, but the effect on
cothreads calling <a class="reference internal" href="#cothread.Event.Wait" title="cothread.Event.Wait"><tt class="xref py py-meth docutils literal"><span class="pre">Wait()</span></tt></a> is that they will receive the given
exception.</p>
</dd></dl>

<dl class="method">
<dt id="cothread.Event.Reset">
<tt class="descname">Reset</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/cothread/cothread.html#Event.Reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.Event.Reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the signal and erases its value.  Also erases any exception
written to the event.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cothread.EventQueue">
<em class="property">class </em><tt class="descclassname">cothread.</tt><tt class="descname">EventQueue</tt><a class="reference internal" href="_modules/cothread/cothread.html#EventQueue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.EventQueue" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#cothread.EventQueue" title="cothread.EventQueue"><tt class="xref py py-class docutils literal"><span class="pre">EventQueue</span></tt></a> is designed to support the communication of a
stream of values between two cothreads.  Calling <tt class="xref py py-func docutils literal"><span class="pre">len()</span></tt> on an event
queue returns the number of entries currently in its queue.  An event
queue can also be consumed as an iterator, see code example below.</p>
<p>The following methods are supported:</p>
<dl class="method">
<dt id="cothread.EventQueue.Wait">
<tt class="descname">Wait</tt><big>(</big><em>timeout=None</em><big>)</big><a class="reference internal" href="_modules/cothread/cothread.html#EventQueue.Wait"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.EventQueue.Wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the next object from the queue, blocking if necessary.  If a
timeout occurs then <tt class="xref py py-exc docutils literal"><span class="pre">Timedout</span></tt> is raised.  If the queue has been
closed then <tt class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></tt> is raised.</p>
<p>If the queue is non empty when <a class="reference internal" href="#cothread.EventQueue.Wait" title="cothread.EventQueue.Wait"><tt class="xref py py-meth docutils literal"><span class="pre">Wait()</span></tt></a> is called control will not
be suspended.</p>
</dd></dl>

<dl class="method">
<dt id="cothread.EventQueue.Signal">
<tt class="descname">Signal</tt><big>(</big><em>value</em><big>)</big><a class="reference internal" href="_modules/cothread/cothread.html#EventQueue.Signal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.EventQueue.Signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the given value to the queue, waking up a waiting cothread if one
is waiting.  This routine does not suspend the caller.</p>
</dd></dl>

<dl class="method">
<dt id="cothread.EventQueue.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/cothread/cothread.html#EventQueue.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.EventQueue.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Marks the queue as closed, after which no more signals can be raised.
Calling <a class="reference internal" href="#cothread.EventQueue.Wait" title="cothread.EventQueue.Wait"><tt class="xref py py-meth docutils literal"><span class="pre">Wait()</span></tt></a> on a closed queue will cause
<tt class="xref py py-const docutils literal"><span class="pre">StopIteration</span></tt> to be raised.</p>
</dd></dl>

<p>Example code using iteration over an <a class="reference internal" href="#cothread.EventQueue" title="cothread.EventQueue"><tt class="xref py py-class docutils literal"><span class="pre">EventQueue</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">consumer</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;consumed&#39;</span><span class="p">,</span> <span class="n">x</span>

<span class="n">eq</span> <span class="o">=</span> <span class="n">EventQueue</span><span class="p">()</span>
<span class="n">Spawn</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="n">eq</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">eq</span><span class="o">.</span><span class="n">Signal</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">Sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="cothread.ThreadedEventQueue">
<em class="property">class </em><tt class="descclassname">cothread.</tt><tt class="descname">ThreadedEventQueue</tt><a class="reference internal" href="_modules/cothread/cothread.html#ThreadedEventQueue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.ThreadedEventQueue" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#cothread.ThreadedEventQueue" title="cothread.ThreadedEventQueue"><tt class="xref py py-class docutils literal"><span class="pre">ThreadedEventQueue</span></tt></a> behaves like an <a class="reference internal" href="#cothread.EventQueue" title="cothread.EventQueue"><tt class="xref py py-class docutils literal"><span class="pre">EventQueue</span></tt></a>, but
is designed to be used to communicate between a Python thread outside of
the cothread library and a cothread.  Communication can occur in either
direction: an outside thread can call <tt class="xref py py-meth docutils literal"><span class="pre">Signal()</span></tt> on a threaded event
queue while a cothread calls <tt class="xref py py-meth docutils literal"><span class="pre">Wait()</span></tt>, or vice versa.</p>
<p>If a thread calls <tt class="xref py py-meth docutils literal"><span class="pre">Wait()</span></tt> it will block until a cothread (or another
thread) calls <tt class="xref py py-meth docutils literal"><span class="pre">Signal()</span></tt>.  If this is undesirable then the field
<tt class="xref py py-attr docutils literal"><span class="pre">wait_descriptor</span></tt> can be waited on using the standard <a class="reference internal" href="#cothread.select" title="cothread.select"><tt class="xref py py-func docutils literal"><span class="pre">select()</span></tt></a>
or <a class="reference internal" href="#cothread.poll" title="cothread.poll"><tt class="xref py py-func docutils literal"><span class="pre">poll()</span></tt></a> functions.  Note that this file handle must <em>only</em> be used
for waiting, and must not be read from!</p>
</dd></dl>

<dl class="class">
<dt id="cothread.Timer">
<em class="property">class </em><tt class="descclassname">cothread.</tt><tt class="descname">Timer</tt><big>(</big><em>timeout</em>, <em>callback</em>, <em>retrigger=False</em>, <em>reuse=False</em>, <em>stack_size=0</em><big>)</big><a class="reference internal" href="_modules/cothread/cothread.html#Timer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.Timer" title="Permalink to this definition">¶</a></dt>
<dd><p>This triggers a call to <cite>callback</cite>, with no arguments, when <cite>timeout</cite>
expires.  If <cite>retrigger</cite> is <tt class="xref py py-const docutils literal"><span class="pre">True</span></tt> then after <cite>callback</cite> completes
the timer will be reenabled and the cycle will repeat, in which case
<cite>timeout</cite> must be a relative timeout, otherwise only one call will occur.
If <cite>retrigger</cite> is <tt class="xref py py-const docutils literal"><span class="pre">False</span></tt> then once the timer has fired it cannot be
reused unless <cite>reuse</cite> is set to <tt class="xref py py-const docutils literal"><span class="pre">True</span></tt>, see <a class="reference internal" href="#cothread.Timer.reset" title="cothread.Timer.reset"><tt class="xref py py-meth docutils literal"><span class="pre">reset()</span></tt></a> below.</p>
<p>The following two methods can be used to control the timer object:</p>
<dl class="method">
<dt id="cothread.Timer.cancel">
<tt class="descname">cancel</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/cothread/cothread.html#Timer.cancel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.Timer.cancel" title="Permalink to this definition">¶</a></dt>
<dd><p>The timer can be cancelled at any time by calling the <a class="reference internal" href="#cothread.Timer.cancel" title="cothread.Timer.cancel"><tt class="xref py py-meth docutils literal"><span class="pre">cancel()</span></tt></a>
method.  The timer will not fire after this call and will no longer be
reusable.  To avoid memory leaks <a class="reference internal" href="#cothread.Timer.cancel" title="cothread.Timer.cancel"><tt class="xref py py-meth docutils literal"><span class="pre">cancel()</span></tt></a> should be called on
timers with either <cite>retrigger</cite> or <cite>reuse</cite> set once they are no longer
needed.</p>
</dd></dl>

<dl class="method">
<dt id="cothread.Timer.reset">
<tt class="descname">reset</tt><big>(</big><em>timeout</em>, <em>retrigger=None</em><big>)</big><a class="reference internal" href="_modules/cothread/cothread.html#Timer.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.Timer.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>This method allows a reusable timer to be controlled.  This applies to
any timer created with either <cite>retrigger</cite> or <cite>reuse</cite> set, but this
method cannot be called after <a class="reference internal" href="#cothread.Timer.cancel" title="cothread.Timer.cancel"><tt class="xref py py-meth docutils literal"><span class="pre">cancel()</span></tt></a> has been called.</p>
<p>A <cite>timeout</cite> of <tt class="xref py py-const docutils literal"><span class="pre">None</span></tt> can be specified to suspend the timer,
otherwise a new timeout must always be specified when calling
<a class="reference internal" href="#cothread.Timer.reset" title="cothread.Timer.reset"><tt class="xref py py-meth docutils literal"><span class="pre">reset()</span></tt></a>.  Any pending timeout will be cancelled when
<a class="reference internal" href="#cothread.Timer.reset" title="cothread.Timer.reset"><tt class="xref py py-meth docutils literal"><span class="pre">reset()</span></tt></a> is called.</p>
<p>A new value for the <cite>retrigger</cite> flag can also be specified.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="cothread.WaitForAll">
<tt class="descclassname">cothread.</tt><tt class="descname">WaitForAll</tt><big>(</big><em>event_list</em>, <em>timeout=None</em><big>)</big><a class="reference internal" href="_modules/cothread/cothread.html#WaitForAll"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.WaitForAll" title="Permalink to this definition">¶</a></dt>
<dd><p>This routine waits for all events in <cite>event_list</cite> to become ready: this is
done by simply iterating through all the events in turn, waiting for them
to complete.  If <cite>timeout</cite> expires then an exception is raised.</p>
<p>Note that if <a class="reference internal" href="#cothread.WaitForAll" title="cothread.WaitForAll"><tt class="xref py py-func docutils literal"><span class="pre">WaitForAll()</span></tt></a> is interrupted early by an exception or
timeout all pending resources for the remaining events in <cite>event_list</cite> will
still be consumed.</p>
</dd></dl>

<dl class="function">
<dt id="cothread.Quit">
<tt class="descclassname">cothread.</tt><tt class="descname">Quit</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/cothread/cothread.html#Quit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.Quit" title="Permalink to this definition">¶</a></dt>
<dt id="cothread.WaitForQuit">
<tt class="descclassname">cothread.</tt><tt class="descname">WaitForQuit</tt><big>(</big><em>catch_interrupt=True</em><big>)</big><a class="reference internal" href="_modules/cothread/cothread.html#WaitForQuit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.WaitForQuit" title="Permalink to this definition">¶</a></dt>
<dd><p>The routine <a class="reference internal" href="#cothread.WaitForQuit" title="cothread.WaitForQuit"><tt class="xref py py-func docutils literal"><span class="pre">WaitForQuit()</span></tt></a> blocks until one of the following occurrs:
<a class="reference internal" href="#cothread.Quit" title="cothread.Quit"><tt class="xref py py-func docutils literal"><span class="pre">Quit()</span></tt></a> is called, <tt class="xref py py-const docutils literal"><span class="pre">SIGINT</span></tt> is received (by pressing control-C),
or the last Qt window is closed.  By default (if <tt class="docutils literal"><span class="pre">catch_interrupt=True</span></tt> is
set) keyboard interrupts are handled by a signal handler which simply calls
<a class="reference internal" href="#cothread.Quit" title="cothread.Quit"><tt class="xref py py-func docutils literal"><span class="pre">Quit()</span></tt></a>.  This means that the only way to interrupt a loop without a
suspension point is to use another signal such as <tt class="xref py py-const docutils literal"><span class="pre">SIGQUIT</span></tt>
(control-\).</p>
<p>This is designed to be used as the final blocking call at the end of the
main program so that other event loops can run.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This use of <cite>catch_interrupt</cite> to set a signal handler is an incompatible
change from cothread 2.0 and earlier.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="cothread.iqt">
<tt class="descclassname">cothread.</tt><tt class="descname">iqt</tt><big>(</big><em>poll_interval=0.05</em>, <em>use_timer=True</em>, <em>argv=sys.argv</em><big>)</big><a class="reference internal" href="_modules/cothread/input_hook.html#iqt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.iqt" title="Permalink to this definition">¶</a></dt>
<dd><p>If Qt is to be used then this routine must be called during initialisation
to enable the Qt event loop and create the initial Qt application instance.
The Qt application instance is returned.</p>
<p>The normal Qt event hook does not work correctly with modal dialogs (because
they run their own message loops) &#8211; typically either a modal window will be
closed immediately, or else will block the the scheduling of other
cothreads, depending on whether <cite>use_timer</cite> is <tt class="xref py py-const docutils literal"><span class="pre">False</span></tt> or
<tt class="xref py py-const docutils literal"><span class="pre">True</span></tt>.</p>
</dd></dl>

<div class="section" id="coselect-and-cosocket-functions">
<h3>1.2.1. Coselect and Cosocket Functions<a class="headerlink" href="#coselect-and-cosocket-functions" title="Permalink to this headline">¶</a></h3>
<p>To enable cothreaded access to sockets and other external event generating
sources the <tt class="xref py py-mod docutils literal"><span class="pre">cothread.coselect</span></tt> library provides coperative implementations
of <a class="reference internal" href="#cothread.select" title="cothread.select"><tt class="xref py py-func docutils literal"><span class="pre">select()</span></tt></a>, <a class="reference internal" href="#cothread.poll" title="cothread.poll"><tt class="xref py py-func docutils literal"><span class="pre">poll()</span></tt></a> and <a class="reference internal" href="#cothread.socket" title="cothread.socket"><tt class="xref py py-class docutils literal"><span class="pre">socket</span></tt></a> from the Python library
<tt class="xref py py-mod docutils literal"><span class="pre">select</span></tt> and <tt class="xref py py-mod docutils literal"><span class="pre">socket</span></tt> modules.  The following methods and classes are
provided:</p>
<dl class="function">
<dt id="cothread.select">
<tt class="descclassname">cothread.</tt><tt class="descname">select</tt><big>(</big><em>iwtd</em>, <em>owtd</em>, <em>ewtd</em>, <em>timeout=None</em><big>)</big><a class="reference internal" href="_modules/cothread/coselect.html#select"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.select" title="Permalink to this definition">¶</a></dt>
<dd><p>Cooperative <a class="reference internal" href="#cothread.select" title="cothread.select"><tt class="xref py py-func docutils literal"><span class="pre">select()</span></tt></a> function, interface compatible with the Python
library <tt class="xref py py-func docutils literal"><span class="pre">select.select()</span></tt> function (though the exceptions raised are
slightly different).</p>
</dd></dl>

<dl class="function">
<dt id="cothread.poll">
<tt class="descclassname">cothread.</tt><tt class="descname">poll</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/cothread/coselect.html#poll"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.poll" title="Permalink to this definition">¶</a></dt>
<dd><p>Cooperative <a class="reference internal" href="#cothread.poll" title="cothread.poll"><tt class="xref py py-func docutils literal"><span class="pre">poll()</span></tt></a> object, interface compatible with the Python
library <tt class="xref py py-class docutils literal"><span class="pre">select.poll</span></tt> object.</p>
</dd></dl>

<dl class="function">
<dt id="cothread.poll_list">
<tt class="descclassname">cothread.</tt><tt class="descname">poll_list</tt><big>(</big><em>event_list</em>, <em>timeout=None</em><big>)</big><a class="reference internal" href="_modules/cothread/coselect.html#poll_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.poll_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Simpler function for waiting for one or more events to occur.  This
function is used to implement the more compatible <a class="reference internal" href="#cothread.select" title="cothread.select"><tt class="xref py py-func docutils literal"><span class="pre">select()</span></tt></a> and
<a class="reference internal" href="#cothread.poll" title="cothread.poll"><tt class="xref py py-class docutils literal"><span class="pre">poll</span></tt></a> interfaces.</p>
<p>The <cite>event_list</cite> parameter is a list of pairs, each consisting of a
waitable descriptor and an event mask (generated by oring together
<tt class="xref py py-const docutils literal"><span class="pre">POLL...</span></tt> constants).  This routine will cooperatively block until
any descriptor signals a selected event (or any event from
<tt class="xref py py-const docutils literal"><span class="pre">POLLHUP</span></tt>, <tt class="xref py py-const docutils literal"><span class="pre">POLLERR</span></tt>, <tt class="xref py py-const docutils literal"><span class="pre">POLLNVAL</span></tt>) or until the
timeout (in seconds) occurs.</p>
</dd></dl>

<dl class="class">
<dt id="cothread.socket">
<em class="property">class </em><tt class="descclassname">cothread.</tt><tt class="descname">socket</tt><big>(</big><em>...</em><big>)</big><a class="reference internal" href="_modules/cothread/cosocket.html#socket"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.socket" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a cooperative non-blocking wrapper of the standard <a class="reference internal" href="#cothread.socket" title="cothread.socket"><tt class="xref py py-class docutils literal"><span class="pre">socket</span></tt></a>
class.  This can be imported directly from <a class="reference internal" href="#module-cothread" title="cothread"><tt class="xref py py-mod docutils literal"><span class="pre">cothread</span></tt></a> and used with
constants and most methods from the standard <tt class="xref py py-mod docutils literal"><span class="pre">socket</span></tt> module, or
alternatively <tt class="docutils literal"><span class="pre">socket_hook()</span></tt> can be called before importing the
<tt class="xref py py-mod docutils literal"><span class="pre">socket</span></tt> module.</p>
</dd></dl>

<dl class="function">
<dt id="cothread.select_hook">
<tt class="descclassname">cothread.</tt><tt class="descname">select_hook</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/cothread/coselect.html#select_hook"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.select_hook" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will replace the <a class="reference internal" href="#cothread.select" title="cothread.select"><tt class="xref py py-func docutils literal"><span class="pre">select()</span></tt></a> and <a class="reference internal" href="#cothread.poll" title="cothread.poll"><tt class="xref py py-class docutils literal"><span class="pre">poll</span></tt></a> methods in
the <tt class="xref py py-mod docutils literal"><span class="pre">select</span></tt> module with the non-blocking cothread compatible functions
defined here.  Do not use this if other threads need to use functions from
the <tt class="xref py py-mod docutils literal"><span class="pre">select</span></tt> module.</p>
</dd></dl>

<dl class="function">
<dt id="cothread.socket_hook">
<tt class="descclassname">cothread.</tt><tt class="descname">socket_hook</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/cothread/cosocket.html#socket_hook"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cothread.socket_hook" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will replace <tt class="xref py py-class docutils literal"><span class="pre">socket.socket</span></tt> in the <tt class="xref py py-mod docutils literal"><span class="pre">socket</span></tt>
module with <a class="reference internal" href="#cothread.socket" title="cothread.socket"><tt class="xref py py-class docutils literal"><span class="pre">cothread.socket</span></tt></a>.  This will convert most Python socket
library functions into cooperative socket functions and allows all of the
helper functions in the <a class="reference internal" href="#cothread.socket" title="cothread.socket"><tt class="xref py py-class docutils literal"><span class="pre">socket</span></tt></a> module to be used.</p>
<p>Note that this function will affect all threads, so if the application
contains a non-cothread thread using sockets this function must not be used.</p>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">1. Using the cothread Library</a><ul>
<li><a class="reference internal" href="#introduction-to-cothreads">1.1. Introduction to Cothreads</a><ul>
<li><a class="reference internal" href="#cothread-suspension-points">1.1.1. Cothread Suspension Points</a></li>
<li><a class="reference internal" href="#order-of-execution">1.1.2. Order of Execution</a></li>
<li><a class="reference internal" href="#callbacks-and-timers">1.1.3. Callbacks and Timers</a></li>
<li><a class="reference internal" href="#timeouts-and-deadlines">1.1.4. Timeouts and Deadlines</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cothread-api">1.2. Cothread API</a><ul>
<li><a class="reference internal" href="#coselect-and-cosocket-functions">1.2.1. Coselect and Cosocket Functions</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Welcome to Cothread&#8217;s documentation!</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="catools.html"
                        title="next chapter">2. Using the catools Library</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/cothread.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="catools.html" title="2. Using the catools Library"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Welcome to Cothread’s documentation!"
             >previous</a> |</li>
        <li><a href="index.html">Cothread  documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Michael Abbott.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.
    </div>
  </body>
</html>